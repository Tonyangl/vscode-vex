{
	"if": {
		"prefix": "if",
		"body": "if ($1) {\n$2\n}",
		"description": "If Statement",
		"scope": "source.vex"
	},
	"else": {
		"prefix": "else",
		"body": "else {\n$1\n}",
		"description": "Else Statement",
		"scope": "source.vex"
	},
	"while": {
		"prefix": "while",
		"body": "while ($1) {\n$2\n}",
		"description": "While Loop",
		"scope": "source.vex"
	},
	"for": {
		"prefix": "for",
		"body": "for (int ${2:i} = 0; $2 < ${1:count}; ${3:++$2}){\n    ${0:/* code */}\n}\n",
		"description": "For Loop (int)",
		"scope": "source.vex"
	},
	"foreach": {
		"prefix": "foreach",
		"body": "foreach (${1:item_type}; ${2:item}; ${3:array}){\n    ${0:/* code */}\n}\n",
		"description": "Foreach Loop",
		"scope": "source.vex"
	},
	// Point Cloud Iterate (exclude).
	"Point Cloud Iterate Excluding Search Point": {
		"prefix": "pce",
		"body": "float search_rad = ${1:10.0};\nint   max_points = ${2:10};\n\nint handle = pcopen(@OpInput1, \"P\", @P, search_rad, max_points+1);\n\nint near_pt;\nvector near_p;\n\nwhile( pciterate(handle) ) {\n    pcimport(handle, \"point:number\", near_pt);\n    if (@ptnum != near_pt) {\n        // found a nearby point that isn't the search position\n        pcimport(handle, \"P\", near_p);\n    }\n}\n\npcclose(handle);\n",
		"description": "Point Cloud Iterate Excluding Search Point (VEXpression)",
		"scope": "source.vex"
	},
	// Point Cloud Iterate.
	"Point Cloud Iterate (VEXpression)": {
		"prefix": "pci",
		"body": "float search_rad = ${1:10.0};\nint   max_points = ${2:10};\n\nint handle = pcopen(${3:0}, \"P\", @P, search_rad, max_points);\n\nvector near_p;\n\nwhile( pciterate(handle) ) {\n    pcimport(handle, \"P\", near_p);\n}\n\npcclose(handle);\n",
		"description": "Point Cloud Iterate (VEXpression)",
		"scope": "source.vex"
	},

	// HOUDINI FUNCTIONS.
	"Du": {
		"body": "Du(${1:value}${2:, ...})",
		"description": "Takes the derivative of the given value with respect to U.",
		"prefix": "Du(value, ...)",
		"scope": "source.vex"
	},
	"Dv": {
		"body": "Dv(${1:value}${2:, ...})",
		"description": "Takes the derivative of the given value with respect to V.",
		"prefix": "Dv(value, ...)",
		"scope": "source.vex"
	},
	"Dw": {
		"body": "Dw(${1:p}${2:, ...})",
		"description": "Takes the derivative of the given value with respect to the 3rd axis, for volume rendering.",
		"prefix": "Dw(p, ...)",
		"scope": "source.vex"
	},
	"abs": {
		"body": "abs(${1:value})",
		"description": "Returns the absolute value of the argument.",
		"prefix": "abs(value)",
		"scope": "source.vex"
	},
	"accessframe": {
		"body": "accessframe(${1:frame})",
		"description": "",
		"prefix": "accessframe(frame)",
		"scope": "source.vex"
	},
	"acos": {
		"body": "acos(${1:v})",
		"description": "Returns the inverse cosine of the argument.",
		"prefix": "acos(v)",
		"scope": "source.vex"
	},
	"addattrib": {
		"body": "addattrib(${1:geohandle}, ${2:attribtype}, ${3:name}, ${4:defvalue})",
		"description": "Adds an attribute to a geometry.",
		"prefix": "addattrib(geohandle, attribtype, name, defvalue)",
		"scope": "source.vex"
	},
	"addattribute": {
		"body": "addattribute(${1:name}, ${2:values}, ${3:capacity}${4:, ...})",
		"prefix": "addattribute(name, values, capacity, ...)",
		"scope": "source.vex"
	},
	"adddetailattrib": {
		"body": "adddetailattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo=\"\"})",
		"description": "Adds an attribute to a geometry.",
		"prefix": "adddetailattrib(geohandle, name, defvalue, typeinfo=\"\")",
		"scope": "source.vex"
	},
	"addgroup": {
		"body": "addgroup(${1:group_name}, ${2:point_number})",
		"prefix": "addgroup(group_name, point_number)",
		"scope": "source.vex"
	},
	"addpoint": {
		"body": "addpoint(${1:geohandle}, ${2:pos})",
		"description": "Adds a point to the geometry.",
		"prefix": "addpoint(geohandle, pos)",
		"scope": "source.vex"
	},
	"addpointattrib": {
		"body": "addpointattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo=\"\"})",
		"description": "Adds an attribute to a geometry.",
		"prefix": "addpointattrib(geohandle, name, defvalue, typeinfo=\"\")",
		"scope": "source.vex"
	},
	"addprim": {
		"body": "addprim(${1:primnum}, ${2:geohandle}, ${3:type}, ${4:points}, ${5:vertices})",
		"description": "Adds a primitive to the geometry.",
		"prefix": "addprim(primnum, geohandle, type, points, vertices)",
		"scope": "source.vex"
	},
	"addprimattrib": {
		"body": "addprimattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo=\"\"})",
		"description": "Adds an attribute to a geometry.",
		"prefix": "addprimattrib(geohandle, name, defvalue, typeinfo=\"\")",
		"scope": "source.vex"
	},
	"addvariablename": {
		"body": "addvariablename(${1:aname}, ${2:vname})",
		"description": "Adds the mapping of the attribute aname to the local variable\nvname.",
		"prefix": "addvariablename(aname, vname)",
		"scope": "source.vex"
	},
	"addvertex": {
		"body": "addvertex(${1:geohandle}, ${2:prim}, ${3:point})",
		"description": "Adds a vertex to the geometry.",
		"prefix": "addvertex(geohandle, prim, point)",
		"scope": "source.vex"
	},
	"addvertexattrib": {
		"body": "addvertexattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo=\"\"})",
		"description": "Adds an attribute to a geometry.",
		"prefix": "addvertexattrib(geohandle, name, defvalue, typeinfo=\"\")",
		"scope": "source.vex"
	},
	"addvisualizer": {
		"body": "addvisualizer(${1:geohandle}, ${2:visualizer})",
		"description": "Appends to the visualizer detail attribute.",
		"prefix": "addvisualizer(geohandle, visualizer)",
		"scope": "source.vex"
	},
	"agentaddclip": {
		"body": "agentaddclip(${1:geohandle}, ${2:prim}, ${3:clipname}, ${4:clippath}, ${5:keepref})",
		"description": "Add a clip into an agent\u2019s definition.",
		"prefix": "agentaddclip(geohandle, prim, clipname, clippath, keepref)",
		"scope": "source.vex"
	},
	"agentclipcatalog": {
		"body": "agentclipcatalog(${1:geometry}, ${2:prim})",
		"description": "Returns all of the animation clips that have been loaded for an agent primitive.",
		"prefix": "agentclipcatalog(geometry, prim)",
		"scope": "source.vex"
	},
	"agentclipchannel": {
		"body": "agentclipchannel(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:channel})",
		"description": "Finds the index of a channel in an agent\u2019s animation clip.",
		"prefix": "agentclipchannel(geometry, prim, clipname, channel)",
		"scope": "source.vex"
	},
	"agentcliplength": {
		"body": "agentcliplength(${1:geometry}, ${2:prim}, ${3:clipname})",
		"description": "Returns the length (in seconds) of an agent\u2019s animation clip.",
		"prefix": "agentcliplength(geometry, prim, clipname)",
		"scope": "source.vex"
	},
	"agentclipnames": {
		"body": "agentclipnames(${1:geometry}, ${2:prim})",
		"description": "Returns an agent primitive\u2019s current animation clips.",
		"prefix": "agentclipnames(geometry, prim)",
		"scope": "source.vex"
	},
	"agentclipsample": {
		"body": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:channel})",
		"description": "Samples a channel of an agent\u2019s clip at a specific time.",
		"prefix": "agentclipsample(geometry, prim, clipname, time, channel)",
		"scope": "source.vex"
	},
	"agentclipsamplelocal": {
		"body": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
		"description": "Samples an agent\u2019s animation clip at a specific time.",
		"prefix": "agentclipsamplelocal(geometry, prim, clipname, time)",
		"scope": "source.vex"
	},
	"agentclipsamplerate": {
		"body": "agentclipsamplerate(${1:geometry}, ${2:prim}, ${3:clipname})",
		"description": "Returns the sample rate of an agent\u2019s animation clip.",
		"prefix": "agentclipsamplerate(geometry, prim, clipname)",
		"scope": "source.vex"
	},
	"agentclipsampleworld": {
		"body": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
		"description": "Samples an agent\u2019s animation clip at a specific time.",
		"prefix": "agentclipsampleworld(geometry, prim, clipname, time)",
		"scope": "source.vex"
	},
	"agentcliptimes": {
		"body": "agentcliptimes(${1:geometry}, ${2:prim})",
		"description": "Returns the current times for an agent primitive\u2019s animation clips.",
		"prefix": "agentcliptimes(geometry, prim)",
		"scope": "source.vex"
	},
	"agentcliptransformgroups": {
		"body": "agentcliptransformgroups(${1:geometry}, ${2:prim})",
		"description": "Returns the transform groups for an agent primitive\u2019s current animation clips.",
		"prefix": "agentcliptransformgroups(geometry, prim)",
		"scope": "source.vex"
	},
	"agentclipweights": {
		"body": "agentclipweights(${1:geometry}, ${2:prim})",
		"description": "Returns the blend weights for an agent primitive\u2019s animation clips.",
		"prefix": "agentclipweights(geometry, prim)",
		"scope": "source.vex"
	},
	"agentcollisionlayer": {
		"body": "agentcollisionlayer(${1:geometry}, ${2:prim})",
		"description": "Returns the name of the collision layer of an agent primitive.",
		"prefix": "agentcollisionlayer(geometry, prim)",
		"scope": "source.vex"
	},
	"agentcurrentlayer": {
		"body": "agentcurrentlayer(${1:geometry}, ${2:prim})",
		"description": "Returns the name of the current layer of an agent primitive.",
		"prefix": "agentcurrentlayer(geometry, prim)",
		"scope": "source.vex"
	},
	"agentlayerbindings": {
		"body": "agentlayerbindings(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
		"description": "Returns the transform that each shape in an agent\u2019s layer is bound to.",
		"prefix": "agentlayerbindings(geometry, prim, layername, shapetype)",
		"scope": "source.vex"
	},
	"agentlayers": {
		"body": "agentlayers(${1:geometry}, ${2:prim})",
		"description": "Returns all of the layers that have been loaded for an agent primitive.",
		"prefix": "agentlayers(geometry, prim)",
		"scope": "source.vex"
	},
	"agentlayershapes": {
		"body": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
		"description": "Returns the names of the shapes referenced by an agent primitive\u2019s layer.",
		"prefix": "agentlayershapes(geometry, prim, layername, shapetype)",
		"scope": "source.vex"
	},
	"agentlocaltransform": {
		"body": "agentlocaltransform(${1:geometry}, ${2:prim}, ${3:transform})",
		"description": "Returns the current local space transform of an agent primitive\u2019s bone.",
		"prefix": "agentlocaltransform(geometry, prim, transform)",
		"scope": "source.vex"
	},
	"agentlocaltransforms": {
		"body": "agentlocaltransforms(${1:geometry}, ${2:prim})",
		"description": "Returns the current local space transforms of an agent primitive.",
		"prefix": "agentlocaltransforms(geometry, prim)",
		"scope": "source.vex"
	},
	"agentrigchildren": {
		"body": "agentrigchildren(${1:geometry}, ${2:prim}, ${3:transform})",
		"description": "Returns the child transforms of a transform in an agent primitive\u2019s rig.",
		"prefix": "agentrigchildren(geometry, prim, transform)",
		"scope": "source.vex"
	},
	"agentrigfind": {
		"body": "agentrigfind(${1:geometry}, ${2:prim}, ${3:transformname})",
		"description": "Finds the index of a transform in an agent primitive\u2019s rig.",
		"prefix": "agentrigfind(geometry, prim, transformname)",
		"scope": "source.vex"
	},
	"agentrigparent": {
		"body": "agentrigparent(${1:geometry}, ${2:prim}, ${3:transform})",
		"description": "Returns the parent transform of a transform in an agent primitive\u2019s rig.",
		"prefix": "agentrigparent(geometry, prim, transform)",
		"scope": "source.vex"
	},
	"agenttransformcount": {
		"body": "agenttransformcount(${1:geometry}, ${2:prim})",
		"description": "Returns the number of transforms in an agent primitive\u2019s rig.",
		"prefix": "agenttransformcount(geometry, prim)",
		"scope": "source.vex"
	},
	"agenttransformgroupmember": {
		"body": "agenttransformgroupmember(${1:geometry}, ${2:prim}, ${3:transformgroup}, ${4:transform})",
		"description": "Returns whether a transform is a member of the specified transform group.",
		"prefix": "agenttransformgroupmember(geometry, prim, transformgroup, transform)",
		"scope": "source.vex"
	},
	"agenttransformgroups": {
		"body": "agenttransformgroups(${1:geometry}, ${2:prim})",
		"description": "Returns the names of the transform groups in an agent\u2019s definition.",
		"prefix": "agenttransformgroups(geometry, prim)",
		"scope": "source.vex"
	},
	"agenttransformnames": {
		"body": "agenttransformnames(${1:geometry}, ${2:prim})",
		"description": "Returns the name of each transform in an agent primitive\u2019s rig.",
		"prefix": "agenttransformnames(geometry, prim)",
		"scope": "source.vex"
	},
	"agenttransformtolocal": {
		"body": "agenttransformtolocal(${1:geometry}, ${2:prim}, ${3:transforms})",
		"description": "Converts transforms from world space to local space for an agent primitive.",
		"prefix": "agenttransformtolocal(geometry, prim, transforms)",
		"scope": "source.vex"
	},
	"agenttransformtoworld": {
		"body": "agenttransformtoworld(${1:geometry}, ${2:prim}, ${3:transforms})",
		"description": "Converts transforms from local space to world space for an agent primitive.",
		"prefix": "agenttransformtoworld(geometry, prim, transforms)",
		"scope": "source.vex"
	},
	"agentworldtransform": {
		"body": "agentworldtransform(${1:geometry}, ${2:prim}, ${3:transform})",
		"description": "Returns the current world space transform of an agent primitive\u2019s bone.",
		"prefix": "agentworldtransform(geometry, prim, transform)",
		"scope": "source.vex"
	},
	"agentworldtransforms": {
		"body": "agentworldtransforms(${1:geometry}, ${2:prim})",
		"description": "Returns the current world space transforms of an agent primitive.",
		"prefix": "agentworldtransforms(geometry, prim)",
		"scope": "source.vex"
	},
	"albedo": {
		"body": "albedo(${1:b}${2:, ...})",
		"description": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction.",
		"prefix": "albedo(b, ...)",
		"scope": "source.vex"
	},
	"alphaname": {
		"body": "alphaname()",
		"description": "Returns the default name of the alpha plane (as it appears in the\ncompositor preferences).",
		"prefix": "alphaname()",
		"scope": "source.vex"
	},
	"ambient": {
		"body": "ambient(${1:...})",
		"description": "Returns the color of ambient light in the scene.",
		"prefix": "ambient(...)",
		"scope": "source.vex"
	},
	"anoise": {
		"body": "anoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
		"description": "These functions are similar to the Worley noise functions listed\nabove.",
		"prefix": "anoise(pos, turbulence, rough, atten)",
		"scope": "source.vex"
	},
	"append": {
		"body": "append(${1:array}, ${2:value})",
		"description": "Adds an item to an array or string.",
		"prefix": "append(array, value)",
		"scope": "source.vex"
	},
	"area": {
		"body": "area(${1:p}${2:, ...})",
		"description": "Returns the area of the micropolygon containing a variable such as P.",
		"prefix": "area(p, ...)",
		"scope": "source.vex"
	},
	"argsort": {
		"body": "argsort(${1:value})",
		"description": "Returns the indices of a sorted version of an array.",
		"prefix": "argsort(value)",
		"scope": "source.vex"
	},
	"array": {
		"body": "array(${1:...})",
		"description": "Efficiently creates an array from its arguments.",
		"prefix": "array(...)",
		"scope": "source.vex"
	},
	"ashikhmin": {
		"body": "ashikhmin(${1:nml}, ${2:exponentx}, ${3:exponenty}, ${4:framex}, ${5:framey}${6:, ...})",
		"description": "Returns a specular BSDF using the Ashikhmin shading model",
		"prefix": "ashikhmin(nml, exponentx, exponenty, framex, framey, ...)",
		"scope": "source.vex"
	},
	"asin": {
		"body": "asin(${1:value})",
		"description": "Returns the inverse sine of the argument.",
		"prefix": "asin(value)",
		"scope": "source.vex"
	},
	"assert_enabled": {
		"body": "assert_enabled()",
		"description": "Returns 1 if the VEX assertions are enabled (see HOUDINI_VEX_ASSERT) or 0 if assertions are disabled.",
		"prefix": "assert_enabled()",
		"scope": "source.vex"
	},
	"assign": {
		"body": "assign(${1:c1}, ${2:c2}, ${3:source})",
		"description": "An efficient way of extracting the components of a vector, vector4,\nmatrix3 or matrix to float variables.",
		"prefix": "assign(c1, c2, source)",
		"scope": "source.vex"
	},
	"atan": {
		"body": "atan(${1:y}, ${2:x})",
		"description": "Returns the inverse tangent of the argument.",
		"prefix": "atan(y, x)",
		"scope": "source.vex"
	},
	"atan2": {
		"body": "atan2(${1:y}, ${2:x})",
		"description": "Returns the inverse tangent of y/x.",
		"prefix": "atan2(y, x)",
		"scope": "source.vex"
	},
	"atof": {
		"body": "atof(${1:str})",
		"description": "Converts a string to a float.",
		"prefix": "atof(str)",
		"scope": "source.vex"
	},
	"atoi": {
		"body": "atoi(${1:str})",
		"description": "Converts a string to an integer.",
		"prefix": "atoi(str)",
		"scope": "source.vex"
	},
	"atten": {
		"body": "atten(${1:attenuation}, ${2:distance})",
		"description": "Computes attenuated falloff.",
		"prefix": "atten(attenuation, distance)",
		"scope": "source.vex"
	},
	"attrib": {
		"body": "attrib(${1:geometry}, ${2:attribclass}, ${3:name}, ${4:elemnum})",
		"description": "Reads an attribute value from geometry.",
		"prefix": "attrib(geometry, attribclass, name, elemnum)",
		"scope": "source.vex"
	},
	"attribclass": {
		"body": "attribclass(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the class of a geometry attribute.",
		"prefix": "attribclass(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"attribsize": {
		"body": "attribsize(${1:geometry}, ${2:attribute_class}, ${3:attribute_name})",
		"description": "Returns the size of a geometry attribute.",
		"prefix": "attribsize(geometry, attribute_class, attribute_name)",
		"scope": "source.vex"
	},
	"attribtype": {
		"body": "attribtype(${1:geometry}, ${2:attribute_class}, ${3:attribute_name})",
		"description": "Returns the type of a geometry attribute.",
		"prefix": "attribtype(geometry, attribute_class, attribute_name)",
		"scope": "source.vex"
	},
	"attribtypeinfo": {
		"body": "attribtypeinfo(${1:geometry}, ${2:attribute_class}, ${3:attribute_name})",
		"description": "Returns the type info of a geometry attribute.",
		"prefix": "attribtypeinfo(geometry, attribute_class, attribute_name)",
		"scope": "source.vex"
	},
	"avg": {
		"body": "avg(${1:v})",
		"description": "Returns the average value of the input(s)",
		"prefix": "avg(v)",
		"scope": "source.vex"
	},
	"binput": {
		"body": "binput(${1:input}, ${2:plane}, ${3:array_index}, ${4:u}, ${5:v}, ${6:time}${7:, ...})",
		"description": "Returns bilinearly sampled input.",
		"prefix": "binput(input, plane, array_index, u, v, time, ...)",
		"scope": "source.vex"
	},
	"blackbody": {
		"body": "blackbody(${1:temperature}, ${2:luminance})",
		"description": "Compute the color value of an incandescent black body.",
		"prefix": "blackbody(temperature, luminance)",
		"scope": "source.vex"
	},
	"blinn": {
		"body": "blinn(${1:nml}, ${2:V}, ${3:roughness}${4:, ...})",
		"description": "Returns the illumination for specular highlights using the Blinn model.",
		"prefix": "blinn(nml, V, roughness, ...)",
		"scope": "source.vex"
	},
	"blinnBRDF": {
		"body": "blinnBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
		"description": "",
		"prefix": "blinnBRDF(L, N, V, rough)",
		"scope": "source.vex"
	},
	"bouncelabel": {
		"body": "bouncelabel(${1:mask})",
		"description": "",
		"prefix": "bouncelabel(mask)",
		"scope": "source.vex"
	},
	"bouncemask": {
		"body": "bouncemask(${1:labels})",
		"description": "",
		"prefix": "bouncemask(labels)",
		"scope": "source.vex"
	},
	"bumpmap": {
		"body": "bumpmap(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmap(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpmapA": {
		"body": "bumpmapA(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmapA(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpmapB": {
		"body": "bumpmapB(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmapB(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpmapG": {
		"body": "bumpmapG(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmapG(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpmapL": {
		"body": "bumpmapL(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmapL(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpmapR": {
		"body": "bumpmapR(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "bumpmapR(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"bumpname": {
		"body": "bumpname()",
		"description": "Returns the default name of the bump plane (as it appears in the\ncompositor preferences).",
		"prefix": "bumpname()",
		"scope": "source.vex"
	},
	"cbrt": {
		"body": "cbrt(${1:value})",
		"description": "Returns the cube root of the argument.",
		"prefix": "cbrt(value)",
		"scope": "source.vex"
	},
	"ceil": {
		"body": "ceil(${1:value})",
		"description": "Returns the smallest integer greater than or equal to the argument.",
		"prefix": "ceil(value)",
		"scope": "source.vex"
	},
	"ch": {
		"body": "ch(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "ch(channel, time)",
		"scope": "source.vex"
	},
	"ch3": {
		"body": "ch3(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "ch3(channel, time)",
		"scope": "source.vex"
	},
	"ch4": {
		"body": "ch4(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "ch4(channel, time)",
		"scope": "source.vex"
	},
	"chattr": {
		"body": "chattr(${1:input}, ${2:attrclass}, ${3:attrname}, ${4:track}, ${5:sample}, ${6:ret})",
		"description": "Reads an attribute value on Channels, Clips, Sample or Channel/Sample from a connected CHOP input.",
		"prefix": "chattr(input, attrclass, attrname, track, sample, ret)",
		"scope": "source.vex"
	},
	"chend": {
		"body": "chend(${1:input})",
		"description": "Returns the end sample of the input specified.",
		"prefix": "chend(input)",
		"scope": "source.vex"
	},
	"chendf": {
		"body": "chendf(${1:input})",
		"description": "Returns the frame corresponding to the last sample of the input specified.",
		"prefix": "chendf(input)",
		"scope": "source.vex"
	},
	"chendt": {
		"body": "chendt(${1:input})",
		"description": "Returns the time corresponding to the last sample of the input\nspecified.",
		"prefix": "chendt(input)",
		"scope": "source.vex"
	},
	"chf": {
		"body": "chf(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "chf(channel, time)",
		"scope": "source.vex"
	},
	"chi": {
		"body": "chi(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "chi(channel, time)",
		"scope": "source.vex"
	},
	"chindex": {
		"body": "chindex(${1:input}, ${2:name})",
		"description": "Returns the channel index from a input given a channel name.",
		"prefix": "chindex(input, name)",
		"scope": "source.vex"
	},
	"chinput": {
		"body": "chinput(${1:input}, ${2:channel}, ${3:sample})",
		"description": "Returns the value of a channel at the specified sample in an\ninput.",
		"prefix": "chinput(input, channel, sample)",
		"scope": "source.vex"
	},
	"chname": {
		"body": "chname(${1:planeindex}, ${2:chindex})",
		"description": "Returns the channel name of the indexed plane.",
		"prefix": "chname(planeindex, chindex)",
		"scope": "source.vex"
	},
	"chnumchan": {
		"body": "chnumchan(${1:input})",
		"description": "Returns the number of channels in the input specified.",
		"prefix": "chnumchan(input)",
		"scope": "source.vex"
	},
	"chp": {
		"body": "chp(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "chp(channel, time)",
		"scope": "source.vex"
	},
	"chr": {
		"body": "chr(${1:value})",
		"description": "Converts an unicode codepoint to a UTF8 string.",
		"prefix": "chr(value)",
		"scope": "source.vex"
	},
	"chramp": {
		"body": "chramp(${1:channel}, ${2:ramppos}, ${3:time})",
		"description": "Evaluates a ramp parameter and return its value.",
		"prefix": "chramp(channel, ramppos, time)",
		"scope": "source.vex"
	},
	"chrate": {
		"body": "chrate(${1:input})",
		"description": "Returns the sample rate of the input specified.",
		"prefix": "chrate(input)",
		"scope": "source.vex"
	},
	"chreadbuf": {
		"body": "chreadbuf(${1:index})",
		"description": "Returns the value of CHOP context temporary buffer at the specified index.",
		"prefix": "chreadbuf(index)",
		"scope": "source.vex"
	},
	"chresizebuf": {
		"body": "chresizebuf(${1:size})",
		"description": "Resize the CHOP context temporary buffer",
		"prefix": "chresizebuf(size)",
		"scope": "source.vex"
	},
	"chs": {
		"body": "chs(${1:channel}, ${2:time})",
		"description": "Evaluates a channel (or parameter) and return its value.",
		"prefix": "chs(channel, time)",
		"scope": "source.vex"
	},
	"chsetattr": {
		"body": "chsetattr(${1:attrclass}, ${2:attrname}, ${3:track}, ${4:sample}, ${5:value})",
		"description": "Writes an attribute value on Channels, Clips, Sample or Channel/Sample.",
		"prefix": "chsetattr(attrclass, attrname, track, sample, value)",
		"scope": "source.vex"
	},
	"chsraw": {
		"body": "chsraw(${1:channel})",
		"description": "Returns the raw string channel (or parameter).",
		"prefix": "chsraw(channel)",
		"scope": "source.vex"
	},
	"chstart": {
		"body": "chstart(${1:input})",
		"description": "Returns the start sample of the input specified.",
		"prefix": "chstart(input)",
		"scope": "source.vex"
	},
	"chstartf": {
		"body": "chstartf(${1:input})",
		"description": "Returns the frame corresponding to the first sample of the input\nspecified.",
		"prefix": "chstartf(input)",
		"scope": "source.vex"
	},
	"chstartt": {
		"body": "chstartt(${1:input})",
		"description": "Returns the time corresponding to the first sample of the input\nspecified.",
		"prefix": "chstartt(input)",
		"scope": "source.vex"
	},
	"chv": {
		"body": "chv(${1:channel}, ${2:time})",
		"description": "Evaluates a channel or parameter, and return its value.",
		"prefix": "chv(channel, time)",
		"scope": "source.vex"
	},
	"chwritebuf": {
		"body": "chwritebuf(${1:index}, ${2:value})",
		"description": "Writes a value of CHOP context temporary buffer at the specified index.",
		"prefix": "chwritebuf(index, value)",
		"scope": "source.vex"
	},
	"cinput": {
		"body": "cinput(${1:input_number}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}${7:, ...})",
		"description": "Returns point sampled input.",
		"prefix": "cinput(input_number, planeindex, arrayindex, u, v, frame, ...)",
		"scope": "source.vex"
	},
	"ckspline": {
		"body": "ckspline(${1:t}, ${2:v0}, ${3:k0}${4:, ...})",
		"description": "Computes a Catmull-Rom (Cardinal) spline between the key points\nspecified.",
		"prefix": "ckspline(t, v0, k0, ...)",
		"scope": "source.vex"
	},
	"clamp": {
		"body": "clamp(${1:value}, ${2:min}, ${3:max})",
		"description": "Returns value clamped between min and max.",
		"prefix": "clamp(value, min, max)",
		"scope": "source.vex"
	},
	"clip": {
		"body": "clip(${1:result}, ${2:p0}, ${3:p1}, ${4:min}, ${5:max})",
		"description": "Clip the line segment between p0 and p1.",
		"prefix": "clip(result, p0, p1, min, max)",
		"scope": "source.vex"
	},
	"colormap": {
		"body": "colormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}${7:, ...})",
		"description": "Looks up a color from a disk image.",
		"prefix": "colormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
		"scope": "source.vex"
	},
	"colorname": {
		"body": "colorname()",
		"description": "Returns the default name of the color plane (as it appears in the\ncompositor preferences).",
		"prefix": "colorname()",
		"scope": "source.vex"
	},
	"computenormal": {
		"body": "computenormal(${1:state})",
		"description": "In the POP and SOP contexts, sets how/whether to recompute normals.\nIn the shading contexts, computes normals.",
		"prefix": "computenormal(state)",
		"scope": "source.vex"
	},
	"concat": {
		"body": "concat(${1:s1}, ${2:s2}${3:, ...})",
		"description": "Concatenate all the strings specified to form a single string.",
		"prefix": "concat(s1, s2, ...)",
		"scope": "source.vex"
	},
	"cone": {
		"body": "cone(${1:foo}, ${2:bar}, ${3:baz}${4:, ...})",
		"description": "",
		"prefix": "cone(foo, bar, baz, ...)",
		"scope": "source.vex"
	},
	"cos": {
		"body": "cos(${1:value})",
		"description": "Returns the cosine of the argument.",
		"prefix": "cos(value)",
		"scope": "source.vex"
	},
	"cosh": {
		"body": "cosh(${1:value})",
		"description": "Returns the hyperbolic cosine of the argument.",
		"prefix": "cosh(value)",
		"scope": "source.vex"
	},
	"cracktransform": {
		"body": "cracktransform(${1:trs}, ${2:xyz}, ${3:c}, ${4:p}, ${5:xform})",
		"description": "Depending on the value of c, returns the translate (c=0), rotate\n(c=1), or scale (c=2) component of the transform (xform).",
		"prefix": "cracktransform(trs, xyz, c, p, xform)",
		"scope": "source.vex"
	},
	"create_cdf": {
		"body": "create_cdf(${1:pdf})",
		"description": "Creates a CDF from an array of input PDF values.",
		"prefix": "create_cdf(pdf)",
		"scope": "source.vex"
	},
	"create_pdf": {
		"body": "create_pdf(${1:values})",
		"description": "Creates a PDF from an array of input values.",
		"prefix": "create_pdf(values)",
		"scope": "source.vex"
	},
	"cross": {
		"body": "cross(${1:v1}, ${2:v2})",
		"description": "Returns the cross product between the two vectors.",
		"prefix": "cross(v1, v2)",
		"scope": "source.vex"
	},
	"cspline": {
		"body": "cspline(${1:t}, ${2:val1}${3:, ...})",
		"description": "Computes a Catmull-Rom (Cardinal) spline between the key points\nspecified.",
		"prefix": "cspline(t, val1, ...)",
		"scope": "source.vex"
	},
	"ctransform": {
		"body": "ctransform(${1:tospace}, ${2:clr})",
		"description": "Transforms between color spaces.",
		"prefix": "ctransform(tospace, clr)",
		"scope": "source.vex"
	},
	"curlnoise": {
		"body": "curlnoise(${1:xyz})",
		"description": "Computes divergence free noise based on Perlin noise.",
		"prefix": "curlnoise(xyz)",
		"scope": "source.vex"
	},
	"curlnoise2d": {
		"body": "curlnoise2d(${1:xyt})",
		"description": "Computes 2d divergence free noise based on Perlin noise.",
		"prefix": "curlnoise2d(xyt)",
		"scope": "source.vex"
	},
	"curlxnoise": {
		"body": "curlxnoise(${1:xyz})",
		"description": "Computes divergence free noise based on Simplex noise.",
		"prefix": "curlxnoise(xyz)",
		"scope": "source.vex"
	},
	"curlxnoise2d": {
		"body": "curlxnoise2d(${1:xyt})",
		"description": "Computes 2d divergence free noise based on simplex noise.",
		"prefix": "curlxnoise2d(xyt)",
		"scope": "source.vex"
	},
	"cvex_bsdf": {
		"body": "cvex_bsdf(${1:eval_cvex_shader}, ${2:sampler_cvex_shader}${3:, ...})",
		"description": "",
		"prefix": "cvex_bsdf(eval_cvex_shader, sampler_cvex_shader, ...)",
		"scope": "source.vex"
	},
	"degrees": {
		"body": "degrees(${1:angle})",
		"description": "Returns the argument from radians into degrees.",
		"prefix": "degrees(angle)",
		"scope": "source.vex"
	},
	"depthmap": {
		"body": "depthmap(${1:filename}, ${2:uvw})",
		"description": "The depthmap functions work on an image which was rendered as a\nz-depth image from mantra.",
		"prefix": "depthmap(filename, uvw)",
		"scope": "source.vex"
	},
	"depthname": {
		"body": "depthname()",
		"description": "Returns the default name of the depth plane (as it appears in the\ncompositor preferences).",
		"prefix": "depthname()",
		"scope": "source.vex"
	},
	"detail": {
		"body": "detail(${1:geometry}, ${2:attribute_name}, ${3:ignored})",
		"description": "Imports a detail attribute value from a geometry.",
		"prefix": "detail(geometry, attribute_name, ignored)",
		"scope": "source.vex"
	},
	"detailattrib": {
		"body": "detailattrib(${1:geometry}, ${2:attribute_name}, ${3:ignored}, ${4:success})",
		"description": "Imports a detail attribute value from a geometry.",
		"prefix": "detailattrib(geometry, attribute_name, ignored, success)",
		"scope": "source.vex"
	},
	"detailattribsize": {
		"body": "detailattribsize(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the size of a geometry detail attribute.",
		"prefix": "detailattribsize(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"detailattribtype": {
		"body": "detailattribtype(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type of a geometry detail attribute.",
		"prefix": "detailattribtype(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"detailattribtypeinfo": {
		"body": "detailattribtypeinfo(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type info of a geometry attribute.",
		"prefix": "detailattribtypeinfo(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"detailintrinsic": {
		"body": "detailintrinsic(${1:geometry}, ${2:intrinsic})",
		"description": "Imports a detail intrinsic from a geometry.",
		"prefix": "detailintrinsic(geometry, intrinsic)",
		"scope": "source.vex"
	},
	"determinant": {
		"body": "determinant(${1:mat})",
		"description": "Computes the determinant of the matrix.",
		"prefix": "determinant(mat)",
		"scope": "source.vex"
	},
	"diffuse": {
		"body": "diffuse(${1:...})",
		"description": "Returns the diffuse (Lambertian) illumination given the normalized\nsurface normal.",
		"prefix": "diffuse(...)",
		"scope": "source.vex"
	},
	"diffuseBRDF": {
		"body": "diffuseBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
		"description": "",
		"prefix": "diffuseBRDF(L, N, V, rough)",
		"scope": "source.vex"
	},
	"dihedral": {
		"body": "dihedral(${1:a}, ${2:b})",
		"description": "Computes the rotation matrix or quaternion which rotates the vector a onto the vector b.",
		"prefix": "dihedral(a, b)",
		"scope": "source.vex"
	},
	"dimport": {
		"body": "dimport(${1:name}, ${2:value})",
		"description": "Imports a variable from the displacement shader for the surface.",
		"prefix": "dimport(name, value)",
		"scope": "source.vex"
	},
	"distance": {
		"body": "distance(${1:pos1}, ${2:pos2})",
		"description": "Returns the distance between the two 3 or 4 dimensional point\narguments.",
		"prefix": "distance(pos1, pos2)",
		"scope": "source.vex"
	},
	"distance2": {
		"body": "distance2(${1:pos1}, ${2:pos2})",
		"description": "Returns the squared distance between the two 3 or 4 dimensional point\narguments.",
		"prefix": "distance2(pos1, pos2)",
		"scope": "source.vex"
	},
	"dot": {
		"body": "dot(${1:a}, ${2:b})",
		"description": "Returns the dot product between the arguments.",
		"prefix": "dot(a, b)",
		"scope": "source.vex"
	},
	"dsmpixel": {
		"body": "dsmpixel(${1:map}, ${2:channel}, ${3:x}, ${4:y}, ${5:values})",
		"description": "Reads the z-records stored in a pixel of a deep shadow map\nor deep camera map.",
		"prefix": "dsmpixel(map, channel, x, y, values)",
		"scope": "source.vex"
	},
	"efit": {
		"body": "efit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
		"description": "Takes the value in the range (omin, omax) and shifts it to the corresponding value in the new range (nmin, nmax).",
		"prefix": "efit(value, omin, omax, nmin, nmax)",
		"scope": "source.vex"
	},
	"eigenvalues": {
		"body": "eigenvalues(${1:nroot}, ${2:mat}, ${3:real}, ${4:imaginary})",
		"description": "Computes the eigenvalues of a matrix.",
		"prefix": "eigenvalues(nroot, mat, real, imaginary)",
		"scope": "source.vex"
	},
	"endswith": {
		"body": "endswith(${1:haystack}, ${2:needle})",
		"description": "Indicates the string ends with the specified string.",
		"prefix": "endswith(haystack, needle)",
		"scope": "source.vex"
	},
	"environment": {
		"body": "environment(${1:texture_filename}, ${2:relect_dir0}, ${3:relect_dir1}, ${4:relect_dir2}, ${5:relect_dir3}${6:, ...})",
		"description": "Returns the color of the environment texture.",
		"prefix": "environment(texture_filename, relect_dir0, relect_dir1, relect_dir2, relect_dir3, ...)",
		"scope": "source.vex"
	},
	"erf": {
		"body": "erf(${1:v})",
		"description": "Gauss error function.",
		"prefix": "erf(v)",
		"scope": "source.vex"
	},
	"erf_inv": {
		"body": "erf_inv(${1:v})",
		"description": "Inverse Gauss error function.",
		"prefix": "erf_inv(v)",
		"scope": "source.vex"
	},
	"erfc": {
		"body": "erfc(${1:v})",
		"description": "Gauss error function\u2019s complement.",
		"prefix": "erfc(v)",
		"scope": "source.vex"
	},
	"error": {
		"body": "error(${1:format}${2:, ...})",
		"description": "Reports a custom runtime VEX error.",
		"prefix": "error(format, ...)",
		"scope": "source.vex"
	},
	"eulertoquaternion": {
		"body": "eulertoquaternion(${1:rotations}, ${2:order})",
		"description": "Creates a vector4 representing a quaternion from euler angles.",
		"prefix": "eulertoquaternion(rotations, order)",
		"scope": "source.vex"
	},
	"eval_bsdf": {
		"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}${4:, ...})",
		"description": "Evaluates a bsdf given two vectors.",
		"prefix": "eval_bsdf(b, viewer, light, ...)",
		"scope": "source.vex"
	},
	"exp": {
		"body": "exp(${1:value})",
		"description": "Returns the exponential function of the argument.",
		"prefix": "exp(value)",
		"scope": "source.vex"
	},
	"expand_udim": {
		"body": "expand_udim(${1:u}, ${2:v}, ${3:path}${4:, ...})",
		"description": "Perform UDIM or UVTILE texture filename expansion.",
		"prefix": "expand_udim(u, v, path, ...)",
		"scope": "source.vex"
	},
	"expandpointgroup": {
		"body": "expandpointgroup(${1:filename}, ${2:groupname})",
		"description": "",
		"prefix": "expandpointgroup(filename, groupname)",
		"scope": "source.vex"
	},
	"expandprimgroup": {
		"body": "expandprimgroup(${1:filename}, ${2:groupname})",
		"description": "",
		"prefix": "expandprimgroup(filename, groupname)",
		"scope": "source.vex"
	},
	"fastshadow": {
		"body": "fastshadow(${1:P}, ${2:D}, ${3:bias}${4:, ...})",
		"description": "Sends a ray from the position P along the direction specified by the\ndirection D.",
		"prefix": "fastshadow(P, D, bias, ...)",
		"scope": "source.vex"
	},
	"filamentsample": {
		"body": "filamentsample(${1:filename}, ${2:position})",
		"description": "Samples the velocity field defined by a set of ",
		"prefix": "filamentsample(filename, position)",
		"scope": "source.vex"
	},
	"file_stat": {
		"body": "file_stat(${1:filename}, ${2:stat_data}${3:, ...})",
		"description": "Returns file system status for a given file.",
		"prefix": "file_stat(filename, stat_data, ...)",
		"scope": "source.vex"
	},
	"filtershadow": {
		"body": "filtershadow(${1:P}, ${2:D}, ${3:bias}${4:, ...})",
		"description": "Sends a ray from the position P along direction D.",
		"prefix": "filtershadow(P, D, bias, ...)",
		"scope": "source.vex"
	},
	"filterstep": {
		"body": "filterstep(${1:edge}, ${2:x0}, ${3:x1}${4:, ...})",
		"description": "Returns the anti-aliased weight of the step function.",
		"prefix": "filterstep(edge, x0, x1, ...)",
		"scope": "source.vex"
	},
	"find": {
		"body": "find(${1:array}, ${2:search}, ${3:start}, ${4:end})",
		"description": "Finds an item in an array or string.",
		"prefix": "find(array, search, start, end)",
		"scope": "source.vex"
	},
	"findattribval": {
		"body": "findattribval(${1:file}, ${2:class}, ${3:attribute_name}, ${4:value}, ${5:which=0})",
		"description": "Returns element index where an integer or string attribute has a certain value.",
		"prefix": "findattribval(file, class, attribute_name, value, which=0)",
		"scope": "source.vex"
	},
	"findattribvalcount": {
		"body": "findattribvalcount(${1:file}, ${2:class}, ${3:attribute_name}, ${4:value})",
		"description": "Returns number of elements where an integer or string attribute has a certain value.",
		"prefix": "findattribvalcount(file, class, attribute_name, value)",
		"scope": "source.vex"
	},
	"finput": {
		"body": "finput(${1:input_number}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}${7:, ...})",
		"description": "Returns fully filtered pixel input.",
		"prefix": "finput(input_number, planeindex, arrayindex, u, v, frame, ...)",
		"scope": "source.vex"
	},
	"fit": {
		"body": "fit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
		"description": "Takes the value in the range (omin, omax) and shifts it to the corresponding value in the new range (nmin, nmax).",
		"prefix": "fit(value, omin, omax, nmin, nmax)",
		"scope": "source.vex"
	},
	"fit01": {
		"body": "fit01(${1:value}, ${2:nmin}, ${3:nmax})",
		"description": "Takes the value in the range (0, 1) and shifts it to the corresponding value in the new range (",
		"prefix": "fit01(value, nmin, nmax)",
		"scope": "source.vex"
	},
	"fit10": {
		"body": "fit10(${1:value}, ${2:nmin}, ${3:nmax})",
		"description": "Takes the value in the range (1, 0) and shifts it to the corresponding value in the new range (",
		"prefix": "fit10(value, nmin, nmax)",
		"scope": "source.vex"
	},
	"fit11": {
		"body": "fit11(${1:value}, ${2:nmin}, ${3:nmax})",
		"description": "Takes the value in the range (-1, 1) and shifts it to the corresponding value in the new range (",
		"prefix": "fit11(value, nmin, nmax)",
		"scope": "source.vex"
	},
	"floor": {
		"body": "floor(${1:value})",
		"description": "Returns the largest integer less than or equal to the argument.",
		"prefix": "floor(value)",
		"scope": "source.vex"
	},
	"flownoise": {
		"body": "flownoise(${1:xyz}, ${2:flow})",
		"description": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data.",
		"prefix": "flownoise(xyz, flow)",
		"scope": "source.vex"
	},
	"flowpnoise": {
		"body": "flowpnoise(${1:xyz}, ${2:p}, ${3:flow})",
		"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.",
		"prefix": "flowpnoise(xyz, p, flow)",
		"scope": "source.vex"
	},
	"frac": {
		"body": "frac(${1:value})",
		"description": "Returns the fractional component of the floating point number.",
		"prefix": "frac(value)",
		"scope": "source.vex"
	},
	"fresnel": {
		"body": "fresnel(${1:i}, ${2:n}, ${3:eta}, ${4:kr}, ${5:kt}, ${6:R}, ${7:T})",
		"description": "Computes the fresnel reflection/refraction contributions given an\nincoming vector, surface normal (both normalized), and an index of\nrefraction (eta).",
		"prefix": "fresnel(i, n, eta, kr, kt, R, T)",
		"scope": "source.vex"
	},
	"fromNDC": {
		"body": "fromNDC(${1:point})",
		"description": "Transforms a position from normal device coordinates to the\ncoordinates in the appropriate space.",
		"prefix": "fromNDC(point)",
		"scope": "source.vex"
	},
	"frontface": {
		"body": "frontface(${1:N}, ${2:I}, ${3:Nref})",
		"description": "If dot(I, Nref) is less than zero, N will be negated.",
		"prefix": "frontface(N, I, Nref)",
		"scope": "source.vex"
	},
	"fuzzify": {
		"body": "fuzzify(${1:ramp_basis}, ${2:ramp_values}, ${3:ramp_positions}, ${4:crisp_value}, ${5:min_value}, ${6:max_value})",
		"description": "",
		"prefix": "fuzzify(ramp_basis, ramp_values, ramp_positions, crisp_value, min_value, max_value)",
		"scope": "source.vex"
	},
	"fuzzy_and": {
		"body": "fuzzy_and(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_and(v1, v2, ...)",
		"scope": "source.vex"
	},
	"fuzzy_defuzz_centroid": {
		"body": "fuzzy_defuzz_centroid(${1:aggregated_membership}, ${2:min_value}, ${3:max_value})",
		"description": "",
		"prefix": "fuzzy_defuzz_centroid(aggregated_membership, min_value, max_value)",
		"scope": "source.vex"
	},
	"fuzzy_nand": {
		"body": "fuzzy_nand(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_nand(v1, v2, ...)",
		"scope": "source.vex"
	},
	"fuzzy_nor": {
		"body": "fuzzy_nor(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_nor(v1, v2, ...)",
		"scope": "source.vex"
	},
	"fuzzy_not": {
		"body": "fuzzy_not(${1:v})",
		"description": "",
		"prefix": "fuzzy_not(v)",
		"scope": "source.vex"
	},
	"fuzzy_nxor": {
		"body": "fuzzy_nxor(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_nxor(v1, v2, ...)",
		"scope": "source.vex"
	},
	"fuzzy_or": {
		"body": "fuzzy_or(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_or(v1, v2, ...)",
		"scope": "source.vex"
	},
	"fuzzy_xor": {
		"body": "fuzzy_xor(${1:v1}, ${2:v2}${3:, ...})",
		"description": "",
		"prefix": "fuzzy_xor(v1, v2, ...)",
		"scope": "source.vex"
	},
	"geoself": {
		"body": "geoself()",
		"description": "Returns a handle to the current geometry.",
		"prefix": "geoself()",
		"scope": "source.vex"
	},
	"geounwrap": {
		"body": "geounwrap(${1:path}, ${2:unwrap_attribute})",
		"description": "Returns an oppath string to unwrap the geometry inplace.",
		"prefix": "geounwrap(path, unwrap_attribute)",
		"scope": "source.vex"
	},
	"getattrib": {
		"body": "getattrib(${1:geometry}, ${2:attribclass}, ${3:name}, ${4:elemnum}, ${5:success})",
		"description": "Reads an attribute value from geometry, with validity check.",
		"prefix": "getattrib(geometry, attribclass, name, elemnum, success)",
		"scope": "source.vex"
	},
	"getattribute": {
		"body": "getattribute(${1:geometry}, ${2:value}, ${3:attribute_class}, ${4:attribute_name}, ${5:number}, ${6:vertex_number})",
		"description": "Copies the value of a geometry attribute into a variable.",
		"prefix": "getattribute(geometry, value, attribute_class, attribute_name, number, vertex_number)",
		"scope": "source.vex"
	},
	"getbbox": {
		"body": "getbbox(${1:min}, ${2:max})",
		"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry.",
		"prefix": "getbbox(min, max)",
		"scope": "source.vex"
	},
	"getbbox_center": {
		"body": "getbbox_center(${1:filename}, ${2:primgroup})",
		"description": "Returns the center of the bounding box for the geometry.",
		"prefix": "getbbox_center(filename, primgroup)",
		"scope": "source.vex"
	},
	"getbbox_max": {
		"body": "getbbox_max(${1:filename}, ${2:primgroup})",
		"description": "Returns the maximum of the bounding box for the geometry.",
		"prefix": "getbbox_max(filename, primgroup)",
		"scope": "source.vex"
	},
	"getbbox_min": {
		"body": "getbbox_min(${1:filename}, ${2:primgroup})",
		"description": "Returns the minimum of the bounding box for the geometry.",
		"prefix": "getbbox_min(filename, primgroup)",
		"scope": "source.vex"
	},
	"getbbox_size": {
		"body": "getbbox_size(${1:filename}, ${2:primgroup})",
		"description": "Returns the size of the bounding box for the geometry.",
		"prefix": "getbbox_size(filename, primgroup)",
		"scope": "source.vex"
	},
	"getblurP": {
		"body": "getblurP(${1:delta})",
		"description": "Returns the blurred point position (",
		"prefix": "getblurP(delta)",
		"scope": "source.vex"
	},
	"getbounces": {
		"body": "getbounces(${1:b})",
		"description": "",
		"prefix": "getbounces(b)",
		"scope": "source.vex"
	},
	"getbounds": {
		"body": "getbounds(${1:filename}, ${2:min}, ${3:max})",
		"description": "Returns the bounding box of the geometry specified by the filename.",
		"prefix": "getbounds(filename, min, max)",
		"scope": "source.vex"
	},
	"getcomp": {
		"body": "getcomp(${1:vec}, ${2:index})",
		"description": "Extracts a single component of a vector type, matrix type, or array.",
		"prefix": "getcomp(vec, index)",
		"scope": "source.vex"
	},
	"getcomponents": {
		"body": "getcomponents()",
		"description": "",
		"prefix": "getcomponents()",
		"scope": "source.vex"
	},
	"getderiv": {
		"body": "getderiv(${1:attr}, ${2:attrName}, ${3:isVertexAttr}, ${4:s}, ${5:t}, ${6:du}, ${7:dv}${8:, ...})",
		"description": "Evaluates surface derivatives of an attribute.",
		"prefix": "getderiv(attr, attrName, isVertexAttr, s, t, du, dv, ...)",
		"scope": "source.vex"
	},
	"getfogname": {
		"body": "getfogname()",
		"description": "Returns the name of the current object whose shader is being run.",
		"prefix": "getfogname()",
		"scope": "source.vex"
	},
	"getglobalraylevel": {
		"body": "getglobalraylevel()",
		"description": "Returns the depth of the ray tree for computing global\nillumination.",
		"prefix": "getglobalraylevel()",
		"scope": "source.vex"
	},
	"getgroupid": {
		"body": "getgroupid()",
		"description": "Returns group id containing current primitive.",
		"prefix": "getgroupid()",
		"scope": "source.vex"
	},
	"getlight": {
		"body": "getlight(${1:lid})",
		"description": "Returns a light struct for the specified light identifier.",
		"prefix": "getlight(lid)",
		"scope": "source.vex"
	},
	"getlightid": {
		"body": "getlightid(${1:lightname})",
		"description": "Returns the light id for a named light (or -1 for an invalid name).",
		"prefix": "getlightid(lightname)",
		"scope": "source.vex"
	},
	"getlightname": {
		"body": "getlightname(${1:lightid})",
		"description": "Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name.",
		"prefix": "getlightname(lightid)",
		"scope": "source.vex"
	},
	"getlights": {
		"body": "getlights(${1:pos}${2:, ...})",
		"description": "Returns an array of light identifiers for the currently shaded surface.",
		"prefix": "getlights(pos, ...)",
		"scope": "source.vex"
	},
	"getlightscope": {
		"body": "getlightscope(${1:mat}, ${2:scope}, ${3:categories})",
		"description": "Returns a selection of lights that illuminate a given material.",
		"prefix": "getlightscope(mat, scope, categories)",
		"scope": "source.vex"
	},
	"getlocalcurvature": {
		"body": "getlocalcurvature(${1:s}, ${2:t})",
		"description": "Evaluates local curvature of primitive grid, using the same curvature evaluation method as Measure SOPs.",
		"prefix": "getlocalcurvature(s, t)",
		"scope": "source.vex"
	},
	"getmaterial": {
		"body": "getmaterial()",
		"description": "Returns a material struct for the current surface.",
		"prefix": "getmaterial()",
		"scope": "source.vex"
	},
	"getmaterialid": {
		"body": "getmaterialid()",
		"description": "Returns material id of shaded primitive.",
		"prefix": "getmaterialid()",
		"scope": "source.vex"
	},
	"getobjectid": {
		"body": "getobjectid()",
		"description": "Returns the object id for the current shading context.",
		"prefix": "getobjectid()",
		"scope": "source.vex"
	},
	"getobjectname": {
		"body": "getobjectname()",
		"description": "Returns the name of the current object whose shader is being run.",
		"prefix": "getobjectname()",
		"scope": "source.vex"
	},
	"getphotonlight": {
		"body": "getphotonlight()",
		"description": "Returns the integer ID of the light being used for photon shading.",
		"prefix": "getphotonlight()",
		"scope": "source.vex"
	},
	"getpointbbox": {
		"body": "getpointbbox(${1:geometry}, ${2:min}, ${3:max})",
		"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry.",
		"prefix": "getpointbbox(geometry, min, max)",
		"scope": "source.vex"
	},
	"getpointbbox_center": {
		"body": "getpointbbox_center(${1:filename}, ${2:primgroup})",
		"description": "Returns the center of the bounding box for the geometry.",
		"prefix": "getpointbbox_center(filename, primgroup)",
		"scope": "source.vex"
	},
	"getpointbbox_max": {
		"body": "getpointbbox_max(${1:filename}, ${2:primgroup})",
		"description": "Returns the maximum of the bounding box for the geometry.",
		"prefix": "getpointbbox_max(filename, primgroup)",
		"scope": "source.vex"
	},
	"getpointbbox_min": {
		"body": "getpointbbox_min(${1:filename}, ${2:primgroup})",
		"description": "Returns the minimum of the bounding box for the geometry.",
		"prefix": "getpointbbox_min(filename, primgroup)",
		"scope": "source.vex"
	},
	"getpointbbox_size": {
		"body": "getpointbbox_size(${1:filename}, ${2:primgroup})",
		"description": "Returns the size of the bounding box for the geometry.",
		"prefix": "getpointbbox_size(filename, primgroup)",
		"scope": "source.vex"
	},
	"getprimid": {
		"body": "getprimid()",
		"description": "Returns the number of the current primitive.",
		"prefix": "getprimid()",
		"scope": "source.vex"
	},
	"getptextureid": {
		"body": "getptextureid()",
		"description": "Returns the ptexture face id for the current primitive.",
		"prefix": "getptextureid()",
		"scope": "source.vex"
	},
	"getraylevel": {
		"body": "getraylevel()",
		"description": "Returns the depth of the ray tree for the current shading.",
		"prefix": "getraylevel()",
		"scope": "source.vex"
	},
	"getrayweight": {
		"body": "getrayweight()",
		"description": "Returns an approximation to the contribution of the ray to the final\npixel color.",
		"prefix": "getrayweight()",
		"scope": "source.vex"
	},
	"getsamplestore": {
		"body": "getsamplestore(${1:channel}, ${2:P}, ${3:value})",
		"description": "Looks up sample data in a channel, referenced by a point.",
		"prefix": "getsamplestore(channel, P, value)",
		"scope": "source.vex"
	},
	"getscope": {
		"body": "getscope(${1:mat}, ${2:raystyle}, ${3:scope}, ${4:categories})",
		"description": "Returns a selection of objects visible to rays for a given material.",
		"prefix": "getscope(mat, raystyle, scope, categories)",
		"scope": "source.vex"
	},
	"getsmoothP": {
		"body": "getsmoothP(${1:...})",
		"description": "Returns modified surface position based on a smoothing function.",
		"prefix": "getsmoothP(...)",
		"scope": "source.vex"
	},
	"getspace": {
		"body": "getspace(${1:fromspace}, ${2:tospace})",
		"description": "See getspace",
		"prefix": "getspace(fromspace, tospace)",
		"scope": "source.vex"
	},
	"getuvtangents": {
		"body": "getuvtangents(${1:objName}, ${2:P}, ${3:dir}, ${4:Tu}, ${5:Tv}, ${6:Tn})",
		"description": "Evaluates UV tangents at a point on an arbitrary object.",
		"prefix": "getuvtangents(objName, P, dir, Tu, Tv, Tn)",
		"scope": "source.vex"
	},
	"gradient": {
		"body": "gradient(${1:P}, ${2:val}${3:, ...})",
		"description": "Returns the gradient of a field.",
		"prefix": "gradient(P, val, ...)",
		"scope": "source.vex"
	},
	"hair": {
		"body": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}${5:, ...})",
		"description": "",
		"prefix": "hair(N, tip, lobe_shift, lobe_width_lon, ...)",
		"scope": "source.vex"
	},
	"hasattrib": {
		"body": "hasattrib(${1:geometry}, ${2:attribute_class}, ${3:attribute_name})",
		"description": "Checks whether a geometry attribute exists.",
		"prefix": "hasattrib(geometry, attribute_class, attribute_name)",
		"scope": "source.vex"
	},
	"hasdetailattrib": {
		"body": "hasdetailattrib(${1:geometry}, ${2:attribute_name})",
		"description": "Returns if a geometry detail attribute exists.",
		"prefix": "hasdetailattrib(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"haslight": {
		"body": "haslight(${1:mat}, ${2:P}, ${3:light}${4:, ...})",
		"description": "Returns whether a light illuminates the given material.",
		"prefix": "haslight(mat, P, light, ...)",
		"scope": "source.vex"
	},
	"hasmetadata": {
		"body": "hasmetadata(${1:opinput}, ${2:name})",
		"description": "Queries if metadata exists on a composite operator.",
		"prefix": "hasmetadata(opinput, name)",
		"scope": "source.vex"
	},
	"hasplane": {
		"body": "hasplane(${1:planename})",
		"description": "Returns 1 if the plane specified by the parameter exists in this\nCOP.",
		"prefix": "hasplane(planename)",
		"scope": "source.vex"
	},
	"haspointattrib": {
		"body": "haspointattrib(${1:geometry}, ${2:attribute_name})",
		"description": "Returns if a geometry point attribute exists.",
		"prefix": "haspointattrib(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"hasprimattrib": {
		"body": "hasprimattrib(${1:geometry}, ${2:attribute_name})",
		"description": "Returns if a geometry prim attribute exists.",
		"prefix": "hasprimattrib(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"hasvertexattrib": {
		"body": "hasvertexattrib(${1:geometry}, ${2:attribute_name})",
		"description": "Returns if a geometry vertex attribute exists.",
		"prefix": "hasvertexattrib(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"hedge_dstpoint": {
		"body": "hedge_dstpoint(${1:geometry}, ${2:hedge})",
		"description": "Returns the destination point of a half-edge.",
		"prefix": "hedge_dstpoint(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_dstvertex": {
		"body": "hedge_dstvertex(${1:geometry}, ${2:hedge})",
		"description": "Returns the destination vertex of a half-edge.",
		"prefix": "hedge_dstvertex(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_equivcount": {
		"body": "hedge_equivcount(${1:geometry}, ${2:hedge})",
		"description": "Returns the number of half-edges equivalent to a given half-edge.",
		"prefix": "hedge_equivcount(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_isequiv": {
		"body": "hedge_isequiv(${1:geometry}, ${2:hedge1}, ${3:hedge2})",
		"description": "Determines whether a two half-edges are equivalent (represent the same edge).",
		"prefix": "hedge_isequiv(geometry, hedge1, hedge2)",
		"scope": "source.vex"
	},
	"hedge_isprimary": {
		"body": "hedge_isprimary(${1:geometry}, ${2:hedge})",
		"description": "Determines whether a half-edge number corresponds to a primary half-edge.",
		"prefix": "hedge_isprimary(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_isvalid": {
		"body": "hedge_isvalid(${1:geometry}, ${2:hedge})",
		"description": "Determines whether a half-edge number corresponds to a valid half-edge.",
		"prefix": "hedge_isvalid(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_next": {
		"body": "hedge_next(${1:geometry}, ${2:hedge})",
		"description": "Returns the half-edge that follows a given half-edge in its polygon.",
		"prefix": "hedge_next(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_nextequiv": {
		"body": "hedge_nextequiv(${1:geometry}, ${2:hedge})",
		"description": "Returns the next half-edges equivalent to a given half-edge.",
		"prefix": "hedge_nextequiv(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_postdstpoint": {
		"body": "hedge_postdstpoint(${1:geometry}, ${2:hedge})",
		"description": "Returns the point into which the vertex following the destination vertex of a half-edge in its primitive is wired.",
		"prefix": "hedge_postdstpoint(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_postdstvertex": {
		"body": "hedge_postdstvertex(${1:geometry}, ${2:hedge})",
		"description": "Returns the vertex following the destination vertex of a half-edge in its primitive.",
		"prefix": "hedge_postdstvertex(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_presrcpoint": {
		"body": "hedge_presrcpoint(${1:geometry}, ${2:hedge})",
		"description": "Returns the point into which the vertex that precedes the source vertex of a half-edge in its primitive is wired.",
		"prefix": "hedge_presrcpoint(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_presrcvertex": {
		"body": "hedge_presrcvertex(${1:geometry}, ${2:hedge})",
		"description": "Returns the vertex that precedes the source vertex of a half-edge in its primitive.",
		"prefix": "hedge_presrcvertex(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_prev": {
		"body": "hedge_prev(${1:geometry}, ${2:hedge})",
		"description": "Returns the half-edge that precedes a given half-edge in its polygon.",
		"prefix": "hedge_prev(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_prim": {
		"body": "hedge_prim(${1:geometry}, ${2:hedge})",
		"description": "Returns the primitive that contains a half-edge.",
		"prefix": "hedge_prim(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_primary": {
		"body": "hedge_primary(${1:geometry}, ${2:hedge})",
		"description": "Returns the primary half-edge equivalent to a given half-edge.",
		"prefix": "hedge_primary(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_srcpoint": {
		"body": "hedge_srcpoint(${1:geometry}, ${2:hedge})",
		"description": "Returns the source point of a half-edge.",
		"prefix": "hedge_srcpoint(geometry, hedge)",
		"scope": "source.vex"
	},
	"hedge_srcvertex": {
		"body": "hedge_srcvertex(${1:geometry}, ${2:hedge})",
		"description": "Returns the source vertex of a half-edge.",
		"prefix": "hedge_srcvertex(geometry, hedge)",
		"scope": "source.vex"
	},
	"henyeygreenstein": {
		"body": "henyeygreenstein(${1:anisotropic_bias}${2:, ...})",
		"description": "Returns an anisotropic volumetric bsdf, which can scatter light forward or backward.",
		"prefix": "henyeygreenstein(anisotropic_bias, ...)",
		"scope": "source.vex"
	},
	"hscript_noise": {
		"body": "hscript_noise(${1:pos})",
		"description": "Mimics the Houdini expression functions noise(), snoise(), turb(), and\nsturb().",
		"prefix": "hscript_noise(pos)",
		"scope": "source.vex"
	},
	"hscript_rand": {
		"body": "hscript_rand(${1:seed})",
		"description": "Produces the exact same results as the Houdini expression function of\nthe same name.",
		"prefix": "hscript_rand(seed)",
		"scope": "source.vex"
	},
	"hscript_snoise": {
		"body": "hscript_snoise(${1:pos})",
		"description": "",
		"prefix": "hscript_snoise(pos)",
		"scope": "source.vex"
	},
	"hscript_sturb": {
		"body": "hscript_sturb(${1:pos}, ${2:turbulence})",
		"description": "",
		"prefix": "hscript_sturb(pos, turbulence)",
		"scope": "source.vex"
	},
	"hscript_turb": {
		"body": "hscript_turb(${1:pos}, ${2:turbulence})",
		"description": "",
		"prefix": "hscript_turb(pos, turbulence)",
		"scope": "source.vex"
	},
	"hsvtorgb": {
		"body": "hsvtorgb(${1:hsv})",
		"description": "Convert HSV color space into RGB color space.",
		"prefix": "hsvtorgb(hsv)",
		"scope": "source.vex"
	},
	"iaspect": {
		"body": "iaspect(${1:input_number})",
		"description": "Returns the aspect ratio of the specified input.",
		"prefix": "iaspect(input_number)",
		"scope": "source.vex"
	},
	"ichname": {
		"body": "ichname(${1:planeindex}, ${2:chindex}, ${3:input})",
		"description": "Returns the channel name of the indexed plane of the given input (e.",
		"prefix": "ichname(planeindex, chindex, input)",
		"scope": "source.vex"
	},
	"ident": {
		"body": "ident()",
		"description": "Return an identity matrix.",
		"prefix": "ident()",
		"scope": "source.vex"
	},
	"idtopoint": {
		"body": "idtopoint(${1:file}, ${2:id})",
		"description": "Looks up a point number by an id attribute.",
		"prefix": "idtopoint(file, id)",
		"scope": "source.vex"
	},
	"idtoprim": {
		"body": "idtoprim(${1:file}, ${2:id})",
		"description": "Looks up a primitive number by an id attribute.",
		"prefix": "idtoprim(file, id)",
		"scope": "source.vex"
	},
	"iend": {
		"body": "iend(${1:input_number})",
		"description": "Returns the last frame of the specified input.",
		"prefix": "iend(input_number)",
		"scope": "source.vex"
	},
	"iendtime": {
		"body": "iendtime(${1:input_number})",
		"description": "Returns the end time of the specified input.",
		"prefix": "iendtime(input_number)",
		"scope": "source.vex"
	},
	"ihasplane": {
		"body": "ihasplane(${1:input_number}, ${2:planename})",
		"description": "Returns 1 if the specified input has a plane named ",
		"prefix": "ihasplane(input_number, planename)",
		"scope": "source.vex"
	},
	"import": {
		"body": "import(${1:attrib_name}, ${2:values}, ${3:input}, ${4:pt_num})",
		"prefix": "import(attrib_name, values, input, pt_num)",
		"scope": "source.vex"
	},
	"ingroup": {
		"body": "ingroup(${1:group_name}, ${2:point_number})",
		"prefix": "ingroup(group_name, point_number)",
		"scope": "source.vex"
	},
	"inpointgroup": {
		"body": "inpointgroup(${1:filename}, ${2:groupname}, ${3:pointnum})",
		"description": "Returns 1 if the point specified by the point number is in the group specified by the string.",
		"prefix": "inpointgroup(filename, groupname, pointnum)",
		"scope": "source.vex"
	},
	"inprimgroup": {
		"body": "inprimgroup(${1:filename}, ${2:groupname}, ${3:primnum})",
		"description": "Returns 1 if the primitive specified by the primitive number is in the group specified by the string.",
		"prefix": "inprimgroup(filename, groupname, primnum)",
		"scope": "source.vex"
	},
	"insert": {
		"body": "insert(${1:str}, ${2:index}, ${3:value})",
		"description": "Inserts an item, array, or string into an array or string.",
		"prefix": "insert(str, index, value)",
		"scope": "source.vex"
	},
	"instance": {
		"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:pivot})",
		"description": "Creates an instance transform matrix.",
		"prefix": "instance(P, N, scale, pivot)",
		"scope": "source.vex"
	},
	"interpolate": {
		"body": "interpolate(${1:val}, ${2:sx}, ${3:sy})",
		"description": "Interpolates a value across the currently shaded micropolygon.",
		"prefix": "interpolate(val, sx, sy)",
		"scope": "source.vex"
	},
	"intersect": {
		"body": "intersect(${1:filename}, ${2:orig}, ${3:dir}, ${4:p}, ${5:uvw})",
		"description": "This function computes the intersection of the specified ray with the geometry.",
		"prefix": "intersect(filename, orig, dir, p, uvw)",
		"scope": "source.vex"
	},
	"intersect_all": {
		"body": "intersect_all(${1:filename}, ${2:orig}, ${3:dir}, ${4:pos}, ${5:prim}, ${6:uvw}, ${7:tol=0.01}, ${8:ttol=0.01})",
		"description": "This function computes all intersections of the specified ray with the geometry.",
		"prefix": "intersect_all(filename, orig, dir, pos, prim, uvw, tol=0.01, ttol=0.01)",
		"scope": "source.vex"
	},
	"intersect_lights": {
		"body": "intersect_lights(${1:lightids}, ${2:pos}, ${3:dir}, ${4:time}, ${5:idx}, ${6:dist}, ${7:clr}, ${8:scale}${9:, ...})",
		"description": "Finds the nearest intersection of a ray with any of a list of (area) lights and runs the light shader at the intersection point.",
		"prefix": "intersect_lights(lightids, pos, dir, time, idx, dist, clr, scale, ...)",
		"scope": "source.vex"
	},
	"inumplanes": {
		"body": "inumplanes(${1:input_number})",
		"description": "Returns the number of planes in the given input.",
		"prefix": "inumplanes(input_number)",
		"scope": "source.vex"
	},
	"invert": {
		"body": "invert(${1:mat})",
		"description": "Inverts the matrix.",
		"prefix": "invert(mat)",
		"scope": "source.vex"
	},
	"invertexgroup": {
		"body": "invertexgroup(${1:filename}, ${2:groupname}, ${3:vertexnum})",
		"description": "Returns 1 if the vertex specified by the vertex number is in the group specified by the string.",
		"prefix": "invertexgroup(filename, groupname, vertexnum)",
		"scope": "source.vex"
	},
	"iplaneindex": {
		"body": "iplaneindex(${1:input_number}, ${2:planename})",
		"description": "Returns the index of the plane named 'planename' in the specified input.",
		"prefix": "iplaneindex(input_number, planename)",
		"scope": "source.vex"
	},
	"iplanename": {
		"body": "iplanename(${1:input_number}, ${2:planeindex})",
		"description": "Returns the name of the plane specified by the planeindex of the given input",
		"prefix": "iplanename(input_number, planeindex)",
		"scope": "source.vex"
	},
	"iplanesize": {
		"body": "iplanesize(${1:input_number}, ${2:planeindex})",
		"description": "Returns the number of components in the plane named ",
		"prefix": "iplanesize(input_number, planeindex)",
		"scope": "source.vex"
	},
	"irate": {
		"body": "irate(${1:input_number})",
		"description": "Returns the frame rate of the specified input.",
		"prefix": "irate(input_number)",
		"scope": "source.vex"
	},
	"irradiance": {
		"body": "irradiance(${1:P}, ${2:N}${3:, ...})",
		"description": "Computes irradiance (global illumination) at the point P with the\nnormal N.",
		"prefix": "irradiance(P, N, ...)",
		"scope": "source.vex"
	},
	"isalpha": {
		"body": "isalpha(${1:str})",
		"description": "Returns 1 if all the characters in the string are alphabetic",
		"prefix": "isalpha(str)",
		"scope": "source.vex"
	},
	"isbound": {
		"body": "isbound(${1:variable_name})",
		"description": "Parameters in VEX can be overridden by geometry attributes (if the attributes exist on the surface being rendered).",
		"prefix": "isbound(variable_name)",
		"scope": "source.vex"
	},
	"isconnected": {
		"body": "isconnected(${1:input_number})",
		"description": "Returns 1 if input_number is connected, or 0 if the input is not connected.",
		"prefix": "isconnected(input_number)",
		"scope": "source.vex"
	},
	"isdigit": {
		"body": "isdigit(${1:str})",
		"description": "Returns 1 if all the characters in the string are numeric",
		"prefix": "isdigit(str)",
		"scope": "source.vex"
	},
	"isfinite": {
		"body": "isfinite(${1:x})",
		"description": "Checks whether a value is a normal finite number.",
		"prefix": "isfinite(x)",
		"scope": "source.vex"
	},
	"isfogray": {
		"body": "isfogray()",
		"description": "Returns 1 if the shader is being called to evaluate illumination for\nfog objects, or 0 if the light or shadow shader is being called to\nevaluate surface illumination.",
		"prefix": "isfogray()",
		"scope": "source.vex"
	},
	"isframes": {
		"body": "isframes()",
		"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'frames', 0\notherwise.",
		"prefix": "isframes()",
		"scope": "source.vex"
	},
	"isnan": {
		"body": "isnan(${1:x})",
		"description": "Checks whether a value is not a number.",
		"prefix": "isnan(x)",
		"scope": "source.vex"
	},
	"isotropic": {
		"body": "isotropic(${1:...})",
		"description": "Returns an isotropic bsdf, which scatters light equally in all directions.",
		"prefix": "isotropic(...)",
		"scope": "source.vex"
	},
	"israytracing": {
		"body": "israytracing()",
		"description": "Indicates whether a shader is being executed for ray tracing.",
		"prefix": "israytracing()",
		"scope": "source.vex"
	},
	"issamples": {
		"body": "issamples()",
		"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'samples',\n0 otherwise.",
		"prefix": "issamples()",
		"scope": "source.vex"
	},
	"isseconds": {
		"body": "isseconds()",
		"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'seconds',\n0 otherwise.",
		"prefix": "isseconds()",
		"scope": "source.vex"
	},
	"isshadowray": {
		"body": "isshadowray()",
		"description": "Returns 1 if the shader is being called to evaluate opacity for\nshadow rays, or 0 if the shader is being called to evaluate for surface\ncolor.",
		"prefix": "isshadowray()",
		"scope": "source.vex"
	},
	"istart": {
		"body": "istart(${1:input_number})",
		"description": "Returns the starting frame of the specified input.",
		"prefix": "istart(input_number)",
		"scope": "source.vex"
	},
	"istarttime": {
		"body": "istarttime(${1:input_number})",
		"description": "Returns the start time of the specified input.",
		"prefix": "istarttime(input_number)",
		"scope": "source.vex"
	},
	"isuvrendering": {
		"body": "isuvrendering()",
		"description": "Indicats whether the shader is being evaulated while doing UV rendering (e.g. texture unwrapping)",
		"prefix": "isuvrendering()",
		"scope": "source.vex"
	},
	"isvalidindex": {
		"body": "isvalidindex(${1:str}, ${2:index})",
		"description": "Checks if the index given is valid for the array or string given.",
		"prefix": "isvalidindex(str, index)",
		"scope": "source.vex"
	},
	"isvarying": {
		"body": "isvarying(${1:variable})",
		"description": "Check whether a VEX variable is varying or uniform.",
		"prefix": "isvarying(variable)",
		"scope": "source.vex"
	},
	"itoa": {
		"body": "itoa(${1:number})",
		"description": "Converts an integer to a string.",
		"prefix": "itoa(number)",
		"scope": "source.vex"
	},
	"ixres": {
		"body": "ixres(${1:input_number})",
		"description": "Returns the X resolution of the specified input.",
		"prefix": "ixres(input_number)",
		"scope": "source.vex"
	},
	"iyres": {
		"body": "iyres(${1:input_number})",
		"description": "Returns the Y resolution of the specified input.",
		"prefix": "iyres(input_number)",
		"scope": "source.vex"
	},
	"join": {
		"body": "join(${1:s}, ${2:spacer})",
		"description": "Concatenate all the strings of an array inserting a common spacer.",
		"prefix": "join(s, spacer)",
		"scope": "source.vex"
	},
	"kspline": {
		"body": "kspline(${1:basis}, ${2:t}, ${3:v0}, ${4:k0}${5:, ...})",
		"description": "Returns an interpolated value along a spline curve.",
		"prefix": "kspline(basis, t, v0, k0, ...)",
		"scope": "source.vex"
	},
	"len": {
		"body": "len(${1:array})",
		"description": "Returns the length of an array.",
		"prefix": "len(array)",
		"scope": "source.vex"
	},
	"length": {
		"body": "length(${1:vec})",
		"description": "Returns the length of the vector or vector4.",
		"prefix": "length(vec)",
		"scope": "source.vex"
	},
	"length2": {
		"body": "length2(${1:vec})",
		"description": "Returns the squared distance of the vector or vector4.",
		"prefix": "length2(vec)",
		"scope": "source.vex"
	},
	"lerp": {
		"body": "lerp(${1:value1}, ${2:value2}, ${3:amount})",
		"description": "Performs bilinear interpolation between the values.",
		"prefix": "lerp(value1, value2, amount)",
		"scope": "source.vex"
	},
	"lightbounces": {
		"body": "lightbounces(${1:lp})",
		"description": "Returns the bounce mask for a light struct.",
		"prefix": "lightbounces(lp)",
		"scope": "source.vex"
	},
	"lightid": {
		"body": "lightid(${1:lp})",
		"description": "Returns the light id for a light struct.",
		"prefix": "lightid(lp)",
		"scope": "source.vex"
	},
	"limit_sample_space": {
		"body": "limit_sample_space(${1:minu}, ${2:maxu}, ${3:u})",
		"description": "Limits u in ",
		"prefix": "limit_sample_space(minu, maxu, u)",
		"scope": "source.vex"
	},
	"limport": {
		"body": "limport(${1:name}, ${2:value})",
		"description": "Imports a variable from the light shader for the surface.",
		"prefix": "limport(name, value)",
		"scope": "source.vex"
	},
	"lkspline": {
		"body": "lkspline(${1:t}, ${2:v1}, ${3:k1}${4:, ...})",
		"description": "Computes a linear spline between the key points.",
		"prefix": "lkspline(t, v1, k1, ...)",
		"scope": "source.vex"
	},
	"log": {
		"body": "log(${1:value})",
		"description": "Returns the natural logarithm of the argument.",
		"prefix": "log(value)",
		"scope": "source.vex"
	},
	"log10": {
		"body": "log10(${1:value})",
		"description": "Returns the logarithm (base 10) of the argument.",
		"prefix": "log10(value)",
		"scope": "source.vex"
	},
	"lookat": {
		"body": "lookat(${1:from}, ${2:to}, ${3:up}, ${4:xyz})",
		"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation.",
		"prefix": "lookat(from, to, up, xyz)",
		"scope": "source.vex"
	},
	"lspline": {
		"body": "lspline(${1:t}, ${2:val1}${3:, ...})",
		"description": "Computes a linear spline between the key points.",
		"prefix": "lspline(t, val1, ...)",
		"scope": "source.vex"
	},
	"lstrip": {
		"body": "lstrip(${1:value}, ${2:whitespace})",
		"description": "Strips leading whitespace from a string.",
		"prefix": "lstrip(value, whitespace)",
		"scope": "source.vex"
	},
	"luminance": {
		"body": "luminance(${1:vec})",
		"description": "Compute the luminance of the RGB color specified by the parameters.",
		"prefix": "luminance(vec)",
		"scope": "source.vex"
	},
	"lumname": {
		"body": "lumname()",
		"description": "Returns the default name of the luminence plane (as it appears in the\ncompositor preferences).",
		"prefix": "lumname()",
		"scope": "source.vex"
	},
	"makebasis": {
		"body": "makebasis(${1:xaxis}, ${2:yaxis}, ${3:zaxis}, ${4:u})",
		"description": "Creates an orthonormal basis given a z-axis vector.",
		"prefix": "makebasis(xaxis, yaxis, zaxis, u)",
		"scope": "source.vex"
	},
	"maketransform": {
		"body": "maketransform(${1:zaxis}, ${2:yaxis}, ${3:translate})",
		"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix.",
		"prefix": "maketransform(zaxis, yaxis, translate)",
		"scope": "source.vex"
	},
	"maskname": {
		"body": "maskname()",
		"description": "Returns the default name of the mask plane (as it appears in the\ncompositor preferences).",
		"prefix": "maskname()",
		"scope": "source.vex"
	},
	"match": {
		"body": "match(${1:pattern}, ${2:subject})",
		"description": "This function returns 1 if the subject matches the pattern specified,\nor 0 if the subject doesn\u2019t match.",
		"prefix": "match(pattern, subject)",
		"scope": "source.vex"
	},
	"matchvex_blinn": {
		"body": "matchvex_blinn(${1:nml}, ${2:exponent}${3:, ...})",
		"description": "",
		"prefix": "matchvex_blinn(nml, exponent, ...)",
		"scope": "source.vex"
	},
	"matchvex_specular": {
		"body": "matchvex_specular(${1:nml}, ${2:exponent}${3:, ...})",
		"description": "",
		"prefix": "matchvex_specular(nml, exponent, ...)",
		"scope": "source.vex"
	},
	"mattrib": {
		"body": "mattrib(${1:name}, ${2:P})",
		"description": "Returns the value of the point attribute for the metaballs if\nmetaball geometry is specified to i3dgen.",
		"prefix": "mattrib(name, P)",
		"scope": "source.vex"
	},
	"max": {
		"body": "max(${1:value1}, ${2:value2}${3:, ...})",
		"description": "",
		"prefix": "max(value1, value2, ...)",
		"scope": "source.vex"
	},
	"mdensity": {
		"body": "mdensity(${1:P})",
		"description": "Returns the density of the metaball field if metaball geometry is\nspecified to i3dgen.",
		"prefix": "mdensity(P)",
		"scope": "source.vex"
	},
	"metadata": {
		"body": "metadata(${1:opinput}, ${2:name}, ${3:index})",
		"description": "Returns a metadata value from a composite operator.",
		"prefix": "metadata(opinput, name, index)",
		"scope": "source.vex"
	},
	"metaimport": {
		"body": "metaimport(${1:geometry}, ${2:attribute_name}, ${3:pos})",
		"description": "Once you get a handle to a metaball using metastart and metanext, you\ncan query attributes of the metaball with metaimport.",
		"prefix": "metaimport(geometry, attribute_name, pos)",
		"scope": "source.vex"
	},
	"metamarch": {
		"body": "metamarch(${1:index}, ${2:filename}, ${3:p0}, ${4:p1}, ${5:displace_bound})",
		"description": "Takes the ray defined by p0 and p1 and partitions it into zero or\nmore sub-intervals where each interval intersects a cluster of metaballs\nfrom filename.",
		"prefix": "metamarch(index, filename, p0, p1, displace_bound)",
		"scope": "source.vex"
	},
	"metanext": {
		"body": "metanext(${1:handle})",
		"description": "Iterate to the next metaball in the list of metaballs returned by the ",
		"prefix": "metanext(handle)",
		"scope": "source.vex"
	},
	"metastart": {
		"body": "metastart(${1:filename}, ${2:p})",
		"description": "Open a geometry file and return a \"handle\" for the metaballs of\ninterest, at the position p.",
		"prefix": "metastart(filename, p)",
		"scope": "source.vex"
	},
	"metaweight": {
		"body": "metaweight(${1:filename}, ${2:p})",
		"description": "Returns the metaweight of the geometry at position p.",
		"prefix": "metaweight(filename, p)",
		"scope": "source.vex"
	},
	"min": {
		"body": "min(${1:value1}, ${2:value2}${3:, ...})",
		"description": "",
		"prefix": "min(value1, value2, ...)",
		"scope": "source.vex"
	},
	"minpos": {
		"body": "minpos(${1:geometry}, ${2:pt}, ${3:maxdist})",
		"description": "Finds the closest position on the surface of a geometry.",
		"prefix": "minpos(geometry, pt, maxdist)",
		"scope": "source.vex"
	},
	"mspace": {
		"body": "mspace(${1:P})",
		"description": "Transforms the position specified into the \"local\" space of the\nmetaball.",
		"prefix": "mspace(P)",
		"scope": "source.vex"
	},
	"nametopoint": {
		"body": "nametopoint(${1:file}, ${2:name})",
		"description": "Looks up a point number by a name attribute.",
		"prefix": "nametopoint(file, name)",
		"scope": "source.vex"
	},
	"nametoprim": {
		"body": "nametoprim(${1:geometry}, ${2:name})",
		"description": "Looks up a primitive number by a name attribute.",
		"prefix": "nametoprim(geometry, name)",
		"scope": "source.vex"
	},
	"nbouncetypes": {
		"body": "nbouncetypes()",
		"description": "",
		"prefix": "nbouncetypes()",
		"scope": "source.vex"
	},
	"nearpoint": {
		"body": "nearpoint(${1:geometry}, ${2:pt}, ${3:maxdist})",
		"description": "Finds the closest point in a geometry.",
		"prefix": "nearpoint(geometry, pt, maxdist)",
		"scope": "source.vex"
	},
	"nearpoints": {
		"body": "nearpoints(${1:geometry}, ${2:pt}, ${3:maxdist}, ${4:maxpts})",
		"description": "Finds the all the closest point in a geometry.",
		"prefix": "nearpoints(geometry, pt, maxdist, maxpts)",
		"scope": "source.vex"
	},
	"neighbour": {
		"body": "neighbour(${1:filename}, ${2:ptnum}, ${3:neighbournum})",
		"description": "Returns the point index of the neighbour of the point.",
		"prefix": "neighbour(filename, ptnum, neighbournum)",
		"scope": "source.vex"
	},
	"neighbourcount": {
		"body": "neighbourcount(${1:filename}, ${2:ptnum})",
		"description": "Returns the number of points that are connected to the specified point.",
		"prefix": "neighbourcount(filename, ptnum)",
		"scope": "source.vex"
	},
	"neighbours": {
		"body": "neighbours(${1:filename}, ${2:ptnum})",
		"description": "Returns an array of the point numbers of the neighbours of a point.",
		"prefix": "neighbours(filename, ptnum)",
		"scope": "source.vex"
	},
	"newgroup": {
		"body": "newgroup(${1:group_name})",
		"prefix": "newgroup(group_name)",
		"scope": "source.vex"
	},
	"newsampler": {
		"body": "newsampler(${1:seed}${2:, ...})",
		"description": "",
		"prefix": "newsampler(seed, ...)",
		"scope": "source.vex"
	},
	"nextsample": {
		"body": "nextsample(${1:sid}, ${2:svec}${3:, ...})",
		"description": "",
		"prefix": "nextsample(sid, svec, ...)",
		"scope": "source.vex"
	},
	"ninput": {
		"body": "ninput(${1:input_number}, ${2:planeindex}, ${3:arrayindex}, ${4:component}, ${5:u}, ${6:v}, ${7:frame}${8:, ...})",
		"description": "Reads a pixel and its eight neighbors into a 3\u00d73 matrix.",
		"prefix": "ninput(input_number, planeindex, arrayindex, component, u, v, frame, ...)",
		"scope": "source.vex"
	},
	"ninputs": {
		"body": "ninputs()",
		"description": "Returns the number of inputs.",
		"prefix": "ninputs()",
		"scope": "source.vex"
	},
	"noise": {
		"body": "noise(${1:xyz})",
		"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.",
		"prefix": "noise(xyz)",
		"scope": "source.vex"
	},
	"noised": {
		"body": "noised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
		"description": "Derivatives of Perlin Noise.",
		"prefix": "noised(xyz, v, dvdx, dvdy, dvdz)",
		"scope": "source.vex"
	},
	"normal_bsdf": {
		"body": "normal_bsdf(${1:b})",
		"description": "Returns the normal for the diffuse component of a bsdf.",
		"prefix": "normal_bsdf(b)",
		"scope": "source.vex"
	},
	"normalize": {
		"body": "normalize(${1:v})",
		"description": "Returns the normalized vector.",
		"prefix": "normalize(v)",
		"scope": "source.vex"
	},
	"normalname": {
		"body": "normalname()",
		"description": "Returns the default name of the normal plane (as it appears in the\ncompositor preferences).",
		"prefix": "normalname()",
		"scope": "source.vex"
	},
	"npoints": {
		"body": "npoints(${1:filename})",
		"description": "Returns the number of points in the input or geometry file.",
		"prefix": "npoints(filename)",
		"scope": "source.vex"
	},
	"npointsgroup": {
		"body": "npointsgroup(${1:filename}, ${2:groupname})",
		"description": "Returns the number of points in the group.",
		"prefix": "npointsgroup(filename, groupname)",
		"scope": "source.vex"
	},
	"nprimitives": {
		"body": "nprimitives(${1:filename})",
		"description": "Returns the number of primitives in the input or geometry file.",
		"prefix": "nprimitives(filename)",
		"scope": "source.vex"
	},
	"nprimitivesgroup": {
		"body": "nprimitivesgroup(${1:filename}, ${2:groupname})",
		"description": "Returns the number of primitives in the group.",
		"prefix": "nprimitivesgroup(filename, groupname)",
		"scope": "source.vex"
	},
	"nrandom": {
		"body": "nrandom(${1:x}, ${2:y}${3:, ...})",
		"description": "The nrandom() functions are non-deterministic random number\ngenerators for VEX.",
		"prefix": "nrandom(x, y, ...)",
		"scope": "source.vex"
	},
	"ntransform": {
		"body": "ntransform(${1:n}, ${2:transform_matrix})",
		"description": "See ptransform.",
		"prefix": "ntransform(n, transform_matrix)",
		"scope": "source.vex"
	},
	"nuniqueval": {
		"body": "nuniqueval(${1:file}, ${2:class}, ${3:attribute_name})",
		"description": "Returns the number of unique values from an integer or string attribute.",
		"prefix": "nuniqueval(file, class, attribute_name)",
		"scope": "source.vex"
	},
	"nvertices": {
		"body": "nvertices(${1:filename})",
		"description": "Returns the number of vertices in the input or geometry file.",
		"prefix": "nvertices(filename)",
		"scope": "source.vex"
	},
	"nverticesgroup": {
		"body": "nverticesgroup(${1:filename}, ${2:groupname})",
		"description": "Returns the number of vertices in the group.",
		"prefix": "nverticesgroup(filename, groupname)",
		"scope": "source.vex"
	},
	"occlusion": {
		"body": "occlusion(${1:P}, ${2:N}${3:, ...})",
		"description": "Computes ambient occlusion.",
		"prefix": "occlusion(P, N, ...)",
		"scope": "source.vex"
	},
	"ocean_sample": {
		"body": "ocean_sample(${1:geometry}, ${2:phase}, ${3:frequency}, ${4:amplitude}, ${5:hscale}, ${6:time}, ${7:mode}, ${8:downsample}, ${9:pos})",
		"description": "Evaluates an ocean spectrum and samples the result at a given time and location.",
		"prefix": "ocean_sample(geometry, phase, frequency, amplitude, hscale, time, mode, downsample, pos)",
		"scope": "source.vex"
	},
	"ocio_import": {
		"body": "ocio_import(${1:space}, ${2:property}, ${3:value})",
		"description": "Imports attributes from OpenColorIO spaces.",
		"prefix": "ocio_import(space, property, value)",
		"scope": "source.vex"
	},
	"ocio_spaces": {
		"body": "ocio_spaces()",
		"description": "Returns the names of color spaces supported in Open Color IO",
		"prefix": "ocio_spaces()",
		"scope": "source.vex"
	},
	"ocio_transform": {
		"body": "ocio_transform(${1:src}, ${2:dest}, ${3:clr})",
		"description": "Transform colors using Open Color IO",
		"prefix": "ocio_transform(src, dest, clr)",
		"scope": "source.vex"
	},
	"onoise": {
		"body": "onoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
		"description": "These functions are similar to wnoise and vnoise.",
		"prefix": "onoise(pos, turbulence, rough, atten)",
		"scope": "source.vex"
	},
	"opdigits": {
		"body": "opdigits(${1:str})",
		"description": "Returns the integer value of the last sequence of digits of a string",
		"prefix": "opdigits(str)",
		"scope": "source.vex"
	},
	"opend": {
		"body": "opend(${1:operation_id})",
		"description": "End a long operation.",
		"prefix": "opend(operation_id)",
		"scope": "source.vex"
	},
	"opfullpath": {
		"body": "opfullpath(${1:relative_path})",
		"description": "Returns the full path for the given relative path",
		"prefix": "opfullpath(relative_path)",
		"scope": "source.vex"
	},
	"opparentbonetransform": {
		"body": "opparentbonetransform(${1:path}, ${2:time})",
		"description": "Returns the parent bone transform associated with an OP.",
		"prefix": "opparentbonetransform(path, time)",
		"scope": "source.vex"
	},
	"opparenttransform": {
		"body": "opparenttransform(${1:path}, ${2:time})",
		"description": "Returns the parent transform associated with an OP.",
		"prefix": "opparenttransform(path, time)",
		"scope": "source.vex"
	},
	"opparmtransform": {
		"body": "opparmtransform(${1:path}, ${2:time})",
		"description": "Returns the parm transform associated with an OP.",
		"prefix": "opparmtransform(path, time)",
		"scope": "source.vex"
	},
	"oppreconstrainttransform": {
		"body": "oppreconstrainttransform(${1:path}, ${2:time})",
		"description": "Returns the preconstraint transform associated with an OP.",
		"prefix": "oppreconstrainttransform(path, time)",
		"scope": "source.vex"
	},
	"oppretransform": {
		"body": "oppretransform(${1:path}, ${2:time})",
		"description": "Returns the pretransform associated with an OP.",
		"prefix": "oppretransform(path, time)",
		"scope": "source.vex"
	},
	"opstart": {
		"body": "opstart(${1:message})",
		"description": "Start a long operation.",
		"prefix": "opstart(message)",
		"scope": "source.vex"
	},
	"optransform": {
		"body": "optransform(${1:path}, ${2:time})",
		"description": "Returns the transform associated with an OP.",
		"prefix": "optransform(path, time)",
		"scope": "source.vex"
	},
	"ord": {
		"body": "ord(${1:value})",
		"description": "Converts an UTF8 string into a codepoint.",
		"prefix": "ord(value)",
		"scope": "source.vex"
	},
	"osd_facecount": {
		"body": "osd_facecount(${1:filename})",
		"description": "",
		"prefix": "osd_facecount(filename)",
		"scope": "source.vex"
	},
	"osd_firstpatch": {
		"body": "osd_firstpatch(${1:geometry}, ${2:face_id})",
		"description": "",
		"prefix": "osd_firstpatch(geometry, face_id)",
		"scope": "source.vex"
	},
	"osd_limitsurface": {
		"body": "osd_limitsurface(${1:geometry}, ${2:attribute_name}, ${3:face_id}, ${4:u}, ${5:v}, ${6:result})",
		"description": "Evaluates an attribute at the subdivision limit surface using Open Subdiv.",
		"prefix": "osd_limitsurface(geometry, attribute_name, face_id, u, v, result)",
		"scope": "source.vex"
	},
	"osd_limitsurfacevertex": {
		"body": "osd_limitsurfacevertex(${1:geometry}, ${2:attribute_name}, ${3:face_id}, ${4:u}, ${5:v}, ${6:result})",
		"description": "",
		"prefix": "osd_limitsurfacevertex(geometry, attribute_name, face_id, u, v, result)",
		"scope": "source.vex"
	},
	"osd_patchcount": {
		"body": "osd_patchcount(${1:filename}, ${2:face_id})",
		"description": "",
		"prefix": "osd_patchcount(filename, face_id)",
		"scope": "source.vex"
	},
	"osd_patches": {
		"body": "osd_patches(${1:filename}, ${2:face_id})",
		"description": "",
		"prefix": "osd_patches(filename, face_id)",
		"scope": "source.vex"
	},
	"outerproduct": {
		"body": "outerproduct(${1:vec1}, ${2:vec2})",
		"description": "Returns the outer product between the arguments.",
		"prefix": "outerproduct(vec1, vec2)",
		"scope": "source.vex"
	},
	"ow_nspace": {
		"body": "ow_nspace(${1:n})",
		"description": "Transforms a normal vector from Object to World space.",
		"prefix": "ow_nspace(n)",
		"scope": "source.vex"
	},
	"ow_space": {
		"body": "ow_space(${1:v})",
		"description": "Transforms a position value from Object to World space.",
		"prefix": "ow_space(v)",
		"scope": "source.vex"
	},
	"ow_vspace": {
		"body": "ow_vspace(${1:v})",
		"description": "Transforms a direction vector from Object to World space.",
		"prefix": "ow_vspace(v)",
		"scope": "source.vex"
	},
	"pack_inttosafefloat": {
		"body": "pack_inttosafefloat(${1:value})",
		"description": "Reversibly packs an integer into a finite, non-denormal float.",
		"prefix": "pack_inttosafefloat(value)",
		"scope": "source.vex"
	},
	"pathtrace": {
		"body": "pathtrace(${1:P}, ${2:N}${3:, ...})",
		"description": "",
		"prefix": "pathtrace(P, N, ...)",
		"scope": "source.vex"
	},
	"pcclose": {
		"body": "pcclose(${1:handle})",
		"description": "This function closes the handle associated with a pcopen\nfunction.",
		"prefix": "pcclose(handle)",
		"scope": "source.vex"
	},
	"pcconvex": {
		"body": "pcconvex(${1:handle}, ${2:channel}, ${3:N})",
		"description": "",
		"prefix": "pcconvex(handle, channel, N)",
		"scope": "source.vex"
	},
	"pcexport": {
		"body": "pcexport(${1:handle}, ${2:channel_name}, ${3:value}, ${4:radius}${5:, ...})",
		"description": "Writes data to a point cloud inside a\n",
		"prefix": "pcexport(handle, channel_name, value, radius, ...)",
		"scope": "source.vex"
	},
	"pcfarthest": {
		"body": "pcfarthest(${1:handle})",
		"description": "Returns the distance to the farthest point found in the search\nperformed by pcopen.",
		"prefix": "pcfarthest(handle)",
		"scope": "source.vex"
	},
	"pcfilter": {
		"body": "pcfilter(${1:handle}, ${2:channel_name}${3:, ...})",
		"description": "Filters the points found by ",
		"prefix": "pcfilter(handle, channel_name, ...)",
		"scope": "source.vex"
	},
	"pcfind": {
		"body": "pcfind(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints})",
		"description": "Returns a list of closest points from a file.",
		"prefix": "pcfind(filename, Pchannel, P, radius, maxpoints)",
		"scope": "source.vex"
	},
	"pcfind_radius": {
		"body": "pcfind_radius(${1:filename}, ${2:ptgroup}, ${3:Pchannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:radius}, ${8:maxpoints})",
		"description": "Returns a list of closest points from a file taking into account their radii.",
		"prefix": "pcfind_radius(filename, ptgroup, Pchannel, RadChannel, radscale, P, radius, maxpoints)",
		"scope": "source.vex"
	},
	"pcgenerate": {
		"body": "pcgenerate(${1:filename}, ${2:npoints})",
		"description": "Generates a point cloud.",
		"prefix": "pcgenerate(filename, npoints)",
		"scope": "source.vex"
	},
	"pcimport": {
		"body": "pcimport(${1:handle}, ${2:channel_name}, ${3:value})",
		"description": "Imports channel data from a point cloud inside a\n",
		"prefix": "pcimport(handle, channel_name, value)",
		"scope": "source.vex"
	},
	"pcimportbyidx3": {
		"body": "pcimportbyidx3(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidx3(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidx4": {
		"body": "pcimportbyidx4(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidx4(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidxf": {
		"body": "pcimportbyidxf(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidxf(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidxi": {
		"body": "pcimportbyidxi(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidxi(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidxp": {
		"body": "pcimportbyidxp(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidxp(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidxs": {
		"body": "pcimportbyidxs(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidxs(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pcimportbyidxv": {
		"body": "pcimportbyidxv(${1:handle}, ${2:channel_name}, ${3:idx})",
		"description": "Imports channel data from a point cloud outside a ",
		"prefix": "pcimportbyidxv(handle, channel_name, idx)",
		"scope": "source.vex"
	},
	"pciterate": {
		"body": "pciterate(${1:handle})",
		"description": "This function can be used to iterate over all the points which were\nfound in the pcopen query.",
		"prefix": "pciterate(handle)",
		"scope": "source.vex"
	},
	"pcnumfound": {
		"body": "pcnumfound(${1:handle})",
		"description": "This node returns the number of points found by pcopen.",
		"prefix": "pcnumfound(handle)",
		"scope": "source.vex"
	},
	"pcopen": {
		"body": "pcopen(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:Nchannel}, ${5:N}, ${6:radius}, ${7:maxpoints}${8:, ...})",
		"description": "Returns a handle to a point cloud file.",
		"prefix": "pcopen(filename, Pchannel, P, Nchannel, N, radius, maxpoints, ...)",
		"scope": "source.vex"
	},
	"pcopenlod": {
		"body": "pcopenlod(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:min_pts}${5:, ...})",
		"description": "Returns a handle to a point cloud file.",
		"prefix": "pcopenlod(filename, Pchannel, P, min_pts, ...)",
		"scope": "source.vex"
	},
	"pcsampleleaf": {
		"body": "pcsampleleaf(${1:handle}, ${2:sample})",
		"description": "Changes the current iteration point to a leaf descendant of the current aggregate point.",
		"prefix": "pcsampleleaf(handle, sample)",
		"scope": "source.vex"
	},
	"pcsize": {
		"body": "pcsize(${1:handle})",
		"description": "",
		"prefix": "pcsize(handle)",
		"scope": "source.vex"
	},
	"pcunshaded": {
		"body": "pcunshaded(${1:handle}, ${2:channel_name})",
		"description": "Iterate over all of the points of a read-write channel which haven\u2019t\nhad any data written to the channel yet.",
		"prefix": "pcunshaded(handle, channel_name)",
		"scope": "source.vex"
	},
	"pcwrite": {
		"body": "pcwrite(${1:filename}${2:, ...})",
		"description": "Writes data to a point cloud file.",
		"prefix": "pcwrite(filename, ...)",
		"scope": "source.vex"
	},
	"pgfind": {
		"body": "pgfind(${1:filename}, ${2:P}, ${3:radius}, ${4:maxpoints}, ${5:divsize})",
		"description": "Returns a list of closest points from a file.",
		"prefix": "pgfind(filename, P, radius, maxpoints, divsize)",
		"scope": "source.vex"
	},
	"phong": {
		"body": "phong(${1:nml}, ${2:V}, ${3:shinyness}${4:, ...})",
		"description": "Returns the illumination for specular highlights using different lighting models.",
		"prefix": "phong(nml, V, shinyness, ...)",
		"scope": "source.vex"
	},
	"phongBRDF": {
		"body": "phongBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
		"description": "",
		"prefix": "phongBRDF(L, N, V, rough)",
		"scope": "source.vex"
	},
	"phonglobe": {
		"body": "phonglobe(${1:nml}, ${2:dir}, ${3:exponent}${4:, ...})",
		"description": "",
		"prefix": "phonglobe(nml, dir, exponent, ...)",
		"scope": "source.vex"
	},
	"photonmap": {
		"body": "photonmap(${1:mapname}, ${2:P}, ${3:N}, ${4:clr}, ${5:area}${6:, ...})",
		"description": "The photonmap function will evaluate a photon map and return the\nresulting color information.",
		"prefix": "photonmap(mapname, P, N, clr, area, ...)",
		"scope": "source.vex"
	},
	"planeindex": {
		"body": "planeindex(${1:planename})",
		"description": "Returns the index of the plane specified by the parameter, starting\nat zero.",
		"prefix": "planeindex(planename)",
		"scope": "source.vex"
	},
	"planename": {
		"body": "planename(${1:planeindex})",
		"description": "Returns the name of the plane specified by the index (e.",
		"prefix": "planename(planeindex)",
		"scope": "source.vex"
	},
	"planepointdistance": {
		"body": "planepointdistance(${1:plane_pos}, ${2:plane_normal}, ${3:point_pos}, ${4:intersect_pos})",
		"description": "Computes the distance and closest point of a point to an infinite plane.",
		"prefix": "planepointdistance(plane_pos, plane_normal, point_pos, intersect_pos)",
		"scope": "source.vex"
	},
	"planesize": {
		"body": "planesize(${1:planeindex})",
		"description": "Returns the number of components in the plane (1 for scalar planes\nand up to 4 for vector planes).",
		"prefix": "planesize(planeindex)",
		"scope": "source.vex"
	},
	"planesphereintersect": {
		"body": "planesphereintersect(${1:plane_pos}, ${2:plane_normal}, ${3:sphere_pos}, ${4:sphere_radius}, ${5:intersect_pos}, ${6:intersect_radius}, ${7:intersect_distance})",
		"description": "Computes the intersection of a 3D sphere and an infinite 3D plane.",
		"prefix": "planesphereintersect(plane_pos, plane_normal, sphere_pos, sphere_radius, intersect_pos, intersect_radius, intersect_distance)",
		"scope": "source.vex"
	},
	"pluralize": {
		"body": "pluralize(${1:noun})",
		"description": "Converts an English noun to its plural.",
		"prefix": "pluralize(noun)",
		"scope": "source.vex"
	},
	"pnoise": {
		"body": "pnoise(${1:pos}, ${2:period})",
		"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.",
		"prefix": "pnoise(pos, period)",
		"scope": "source.vex"
	},
	"point": {
		"body": "point(${1:geometry}, ${2:attribute_name}, ${3:pointnumber})",
		"description": "Imports a point attribute value from a geometry.",
		"prefix": "point(geometry, attribute_name, pointnumber)",
		"scope": "source.vex"
	},
	"pointattrib": {
		"body": "pointattrib(${1:geometry}, ${2:attribute_name}, ${3:pointnumber}, ${4:success})",
		"description": "Imports a point attribute value from a geometry.",
		"prefix": "pointattrib(geometry, attribute_name, pointnumber, success)",
		"scope": "source.vex"
	},
	"pointattribsize": {
		"body": "pointattribsize(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the size of a geometry point attribute.",
		"prefix": "pointattribsize(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"pointattribtype": {
		"body": "pointattribtype(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type of a geometry point attribute.",
		"prefix": "pointattribtype(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"pointattribtypeinfo": {
		"body": "pointattribtypeinfo(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type info of a geometry attribute.",
		"prefix": "pointattribtypeinfo(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"pointedge": {
		"body": "pointedge(${1:geometry}, ${2:point1}, ${3:point2})",
		"description": "Finds and returns a half-edge with the given endpoints.",
		"prefix": "pointedge(geometry, point1, point2)",
		"scope": "source.vex"
	},
	"pointhedge": {
		"body": "pointhedge(${1:geometry}, ${2:srcpoint}, ${3:dstpoint})",
		"description": "Finds and returns a half-edge with a given source point or with given source and destination points.",
		"prefix": "pointhedge(geometry, srcpoint, dstpoint)",
		"scope": "source.vex"
	},
	"pointhedgenext": {
		"body": "pointhedgenext(${1:geometry}, ${2:hedge})",
		"description": "Returns the ",
		"prefix": "pointhedgenext(geometry, hedge)",
		"scope": "source.vex"
	},
	"pointname": {
		"body": "pointname()",
		"description": "Returns the default name of the point plane (as it appears in the\ncompositor preferences).",
		"prefix": "pointname()",
		"scope": "source.vex"
	},
	"pointprims": {
		"body": "pointprims(${1:geometry}, ${2:ptnum})",
		"description": "Returns the list of primitives containing a point.",
		"prefix": "pointprims(geometry, ptnum)",
		"scope": "source.vex"
	},
	"pointvertex": {
		"body": "pointvertex(${1:geometry}, ${2:pointindex})",
		"description": "Returns a linear vertex number of a point in a geometry.",
		"prefix": "pointvertex(geometry, pointindex)",
		"scope": "source.vex"
	},
	"pointvertices": {
		"body": "pointvertices(${1:geometry}, ${2:ptnum})",
		"description": "Returns the list of vertices connected to a point.",
		"prefix": "pointvertices(geometry, ptnum)",
		"scope": "source.vex"
	},
	"polardecomp": {
		"body": "polardecomp(${1:transform})",
		"description": "Computes the polar decomposition of a matrix.",
		"prefix": "polardecomp(transform)",
		"scope": "source.vex"
	},
	"pop": {
		"body": "pop(${1:array}, ${2:index})",
		"description": "Removes the last element of an array and returns it.",
		"prefix": "pop(array, index)",
		"scope": "source.vex"
	},
	"pow": {
		"body": "pow(${1:value}, ${2:power})",
		"description": "Raises the first argument to the power of the second argument.",
		"prefix": "pow(value, power)",
		"scope": "source.vex"
	},
	"predicate_incircle": {
		"body": "predicate_incircle(${1:a}, ${2:b}, ${3:c}, ${4:d})",
		"description": "Determines if a point is inside or outside a triangle circumcircle.",
		"prefix": "predicate_incircle(a, b, c, d)",
		"scope": "source.vex"
	},
	"predicate_insphere": {
		"body": "predicate_insphere(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e})",
		"description": "Determines if a point is inside or outside a tetrahedron circumsphere.",
		"prefix": "predicate_insphere(a, b, c, d, e)",
		"scope": "source.vex"
	},
	"predicate_orient2d": {
		"body": "predicate_orient2d(${1:a}, ${2:b}, ${3:c})",
		"description": "Determines the orientation of a point with respect to a line.",
		"prefix": "predicate_orient2d(a, b, c)",
		"scope": "source.vex"
	},
	"predicate_orient3d": {
		"body": "predicate_orient3d(${1:a}, ${2:b}, ${3:c}, ${4:d})",
		"description": "Determines the orientation of a point with respect to a plane.",
		"prefix": "predicate_orient3d(a, b, c, d)",
		"scope": "source.vex"
	},
	"prim": {
		"body": "prim(${1:geometry}, ${2:attribute_name}, ${3:prim})",
		"description": "Imports a primitive attribute value from a geometry.",
		"prefix": "prim(geometry, attribute_name, prim)",
		"scope": "source.vex"
	},
	"prim_attribute": {
		"body": "prim_attribute(${1:path}, ${2:value}, ${3:attribute}, ${4:prim_number}, ${5:u}, ${6:v})",
		"description": "Copies the value of a primitive attribute at a certain parametric (u, v) position into a variable.",
		"prefix": "prim_attribute(path, value, attribute, prim_number, u, v)",
		"scope": "source.vex"
	},
	"prim_normal": {
		"body": "prim_normal(${1:filename}, ${2:prim_number}, ${3:uvw})",
		"description": "Returns the normal of the primitive (prim_number) at parametric location u, v.",
		"prefix": "prim_normal(filename, prim_number, uvw)",
		"scope": "source.vex"
	},
	"primarclen": {
		"body": "primarclen(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:pn})",
		"description": "Evaluates an the length of an arc on curves using parametric uv coordinates.",
		"prefix": "primarclen(filename, uv0, uv1, pn)",
		"scope": "source.vex"
	},
	"primattrib": {
		"body": "primattrib(${1:geometry}, ${2:attribute_name}, ${3:prim}, ${4:success})",
		"description": "Imports a primitive attribute value from a geometry.",
		"prefix": "primattrib(geometry, attribute_name, prim, success)",
		"scope": "source.vex"
	},
	"primattribsize": {
		"body": "primattribsize(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the size of a geometry prim attribute.",
		"prefix": "primattribsize(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"primattribtype": {
		"body": "primattribtype(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type of a geometry prim attribute.",
		"prefix": "primattribtype(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"primattribtypeinfo": {
		"body": "primattribtypeinfo(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type info of a geometry attribute.",
		"prefix": "primattribtypeinfo(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"primduv": {
		"body": "primduv(${1:filename}, ${2:pn}, ${3:uv}, ${4:du}, ${5:dv})",
		"description": "Evaluates position derivative on a primitive at a certain parametric (u, v) position into a variable.",
		"prefix": "primduv(filename, pn, uv, du, dv)",
		"scope": "source.vex"
	},
	"primfind": {
		"body": "primfind(${1:geometry}, ${2:min}, ${3:max})",
		"description": "Returns a list of primitives potentially intersecting a given bounding box.",
		"prefix": "primfind(geometry, min, max)",
		"scope": "source.vex"
	},
	"primhedge": {
		"body": "primhedge(${1:geometry}, ${2:prim})",
		"description": "Returns ",
		"prefix": "primhedge(geometry, prim)",
		"scope": "source.vex"
	},
	"primintrinsic": {
		"body": "primintrinsic(${1:geometry}, ${2:intrinsic}, ${3:prim})",
		"description": "Imports a primitive intrinsic from a geometry.",
		"prefix": "primintrinsic(geometry, intrinsic, prim)",
		"scope": "source.vex"
	},
	"primpoint": {
		"body": "primpoint(${1:geometry}, ${2:primnum}, ${3:vertex})",
		"description": "Converts a primitive/vertex pair into a point number.",
		"prefix": "primpoint(geometry, primnum, vertex)",
		"scope": "source.vex"
	},
	"primpoints": {
		"body": "primpoints(${1:geometry}, ${2:primnum})",
		"description": "Returns the list of points on a primitive.",
		"prefix": "primpoints(geometry, primnum)",
		"scope": "source.vex"
	},
	"primuv": {
		"body": "primuv(${1:filename}, ${2:att}, ${3:pn}, ${4:uv})",
		"description": "Evaluates an attribute on a primitive at a certain parametric (u, v) position into a variable.",
		"prefix": "primuv(filename, att, pn, uv)",
		"scope": "source.vex"
	},
	"primuvconvert": {
		"body": "primuvconvert(${1:filename}, ${2:uv}, ${3:pn}, ${4:mode})",
		"description": "Convert parametric UV locations on curve primitives.",
		"prefix": "primuvconvert(filename, uv, pn, mode)",
		"scope": "source.vex"
	},
	"primvertex": {
		"body": "primvertex(${1:geometry}, ${2:primnum}, ${3:vertex})",
		"description": "Converts a primitive/vertex pair into a linear vertex.",
		"prefix": "primvertex(geometry, primnum, vertex)",
		"scope": "source.vex"
	},
	"primvertexcount": {
		"body": "primvertexcount(${1:geometry}, ${2:primindex})",
		"description": "Returns number of vertices in a primitive in a geometry.",
		"prefix": "primvertexcount(geometry, primindex)",
		"scope": "source.vex"
	},
	"primvertices": {
		"body": "primvertices(${1:geometry}, ${2:primnum})",
		"description": "Returns the list of vertices on a primitive.",
		"prefix": "primvertices(geometry, primnum)",
		"scope": "source.vex"
	},
	"print_once": {
		"body": "print_once(${1:msg}${2:, ...})",
		"description": "Prints string arguments exactly one time.",
		"prefix": "print_once(msg, ...)",
		"scope": "source.vex"
	},
	"printf": {
		"body": "printf(${1:format}${2:, ...})",
		"description": "Prints values to the console which started the VEX program.",
		"prefix": "printf(format, ...)",
		"scope": "source.vex"
	},
	"product": {
		"body": "product(${1:v})",
		"description": "Returns the product of the vector\u2019s components.",
		"prefix": "product(v)",
		"scope": "source.vex"
	},
	"ptexture": {
		"body": "ptexture(${1:map}, ${2:face_id}, ${3:s}, ${4:t}${5:, ...})",
		"description": "Computes a filtered sample from a ptex texture map.",
		"prefix": "ptexture(map, face_id, s, t, ...)",
		"scope": "source.vex"
	},
	"ptlined": {
		"body": "ptlined(${1:P0}, ${2:P1}, ${3:Q})",
		"description": "This function returns the closest distance between the point Q and a\nfinite line segment between points P0 and P1.",
		"prefix": "ptlined(P0, P1, Q)",
		"scope": "source.vex"
	},
	"ptransform": {
		"body": "ptransform(${1:tospace}, ${2:v})",
		"description": "Transforms a vector from one space to another.",
		"prefix": "ptransform(tospace, v)",
		"scope": "source.vex"
	},
	"push": {
		"body": "push(${1:array}, ${2:values})",
		"description": "Adds an item to an array.",
		"prefix": "push(array, values)",
		"scope": "source.vex"
	},
	"qconvert": {
		"body": "qconvert(${1:quaternion})",
		"description": "Converts a quaternion represented by a vector4 to a matrix3 representation.",
		"prefix": "qconvert(quaternion)",
		"scope": "source.vex"
	},
	"qdistance": {
		"body": "qdistance(${1:q1}, ${2:q2})",
		"description": "Finds distance between two quaternions.",
		"prefix": "qdistance(q1, q2)",
		"scope": "source.vex"
	},
	"qinvert": {
		"body": "qinvert(${1:quaternion})",
		"description": "Inverts a quaternion rotation.",
		"prefix": "qinvert(quaternion)",
		"scope": "source.vex"
	},
	"qmultiply": {
		"body": "qmultiply(${1:q1}, ${2:q2})",
		"description": "Multiplies two quaternions and returns the result.",
		"prefix": "qmultiply(q1, q2)",
		"scope": "source.vex"
	},
	"qrotate": {
		"body": "qrotate(${1:quaternion}, ${2:a})",
		"description": "Rotates a vector by a quaternion.",
		"prefix": "qrotate(quaternion, a)",
		"scope": "source.vex"
	},
	"quaternion": {
		"body": "quaternion(${1:angleaxis})",
		"description": "Creates a vector4 representing a quaternion.",
		"prefix": "quaternion(angleaxis)",
		"scope": "source.vex"
	},
	"radians": {
		"body": "radians(${1:degrees})",
		"description": "Converts the argument from degrees into radians.",
		"prefix": "radians(degrees)",
		"scope": "source.vex"
	},
	"rand": {
		"body": "rand(${1:seed}, ${2:seed2})",
		"description": "Creates a random number between 0 and 1 from a seed.",
		"prefix": "rand(seed, seed2)",
		"scope": "source.vex"
	},
	"random": {
		"body": "random(${1:xpos}, ${2:ypos})",
		"description": "Generate a random number based on the position in N dimensional space\n(where N is 1 to 4 dimensions).",
		"prefix": "random(xpos, ypos)",
		"scope": "source.vex"
	},
	"random_fhash": {
		"body": "random_fhash(${1:seed}, ${2:seed2})",
		"description": "Hashes floating point numbers to integers.",
		"prefix": "random_fhash(seed, seed2)",
		"scope": "source.vex"
	},
	"random_ihash": {
		"body": "random_ihash(${1:seed})",
		"description": "Hashes integer numbers to integers.",
		"prefix": "random_ihash(seed)",
		"scope": "source.vex"
	},
	"random_shash": {
		"body": "random_shash(${1:seed})",
		"description": "Hashes string to integers.",
		"prefix": "random_shash(seed)",
		"scope": "source.vex"
	},
	"random_sobol": {
		"body": "random_sobol(${1:seed}, ${2:offset})",
		"description": "Generate a uniformly distributed random number.",
		"prefix": "random_sobol(seed, offset)",
		"scope": "source.vex"
	},
	"rawbumpmap": {
		"body": "rawbumpmap(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmap(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawbumpmapA": {
		"body": "rawbumpmapA(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmapA(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawbumpmapB": {
		"body": "rawbumpmapB(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmapB(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawbumpmapG": {
		"body": "rawbumpmapG(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmapG(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawbumpmapL": {
		"body": "rawbumpmapL(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmapL(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawbumpmapR": {
		"body": "rawbumpmapR(${1:filename}, ${2:du}, ${3:dv}, ${4:uvw})",
		"prefix": "rawbumpmapR(filename, du, dv, uvw)",
		"scope": "source.vex"
	},
	"rawcolormap": {
		"body": "rawcolormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}${7:, ...})",
		"description": "",
		"prefix": "rawcolormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
		"scope": "source.vex"
	},
	"rayhittest": {
		"body": "rayhittest(${1:P}, ${2:D}, ${3:pHit}, ${4:nHit}, ${5:bias}${6:, ...})",
		"description": "Sends a ray from the position P along the direction D.",
		"prefix": "rayhittest(P, D, pHit, nHit, bias, ...)",
		"scope": "source.vex"
	},
	"rayimport": {
		"body": "rayimport(${1:name}, ${2:value})",
		"description": "Imports a value sent by a shader in a gather loop.",
		"prefix": "rayimport(name, value)",
		"scope": "source.vex"
	},
	"re_find": {
		"body": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input}, ${5:start}, ${6:end})",
		"description": "Finds the given regular expression in the string",
		"prefix": "re_find(start_pos, end_pos, regex, input, start, end)",
		"scope": "source.vex"
	},
	"re_findall": {
		"body": "re_findall(${1:regex}, ${2:input}, ${3:start}, ${4:end})",
		"description": "Finds all instances of the given regular expression in the string",
		"prefix": "re_findall(regex, input, start, end)",
		"scope": "source.vex"
	},
	"re_match": {
		"body": "re_match(${1:regex}, ${2:input})",
		"description": "Returns 1 if the entire input string matches the expression",
		"prefix": "re_match(regex, input)",
		"scope": "source.vex"
	},
	"re_replace": {
		"body": "re_replace(${1:regex_find}, ${2:regex_replace}, ${3:input}, ${4:maxreplace})",
		"description": "Replaces instances of regex_find with regex_replace",
		"prefix": "re_replace(regex_find, regex_replace, input, maxreplace)",
		"scope": "source.vex"
	},
	"re_split": {
		"body": "re_split(${1:regex}, ${2:input}, ${3:maxsplits})",
		"description": "Splits the given string based on regex match.",
		"prefix": "re_split(regex, input, maxsplits)",
		"scope": "source.vex"
	},
	"reflect": {
		"body": "reflect(${1:direction}, ${2:normal})",
		"description": "Returns the vector representing the reflection of the direction\nagainst the normal.",
		"prefix": "reflect(direction, normal)",
		"scope": "source.vex"
	},
	"reflectlight": {
		"body": "reflectlight(${1:P}, ${2:N}, ${3:I}, ${4:bias}, ${5:max_contrib}${6:, ...})",
		"description": "Computes the amount of reflected light which hits the surface.",
		"prefix": "reflectlight(P, N, I, bias, max_contrib, ...)",
		"scope": "source.vex"
	},
	"refract": {
		"body": "refract(${1:direction}, ${2:normal}, ${3:index})",
		"description": "Returns the refraction ray given an incoming direction, the\nnormalized normal and an index of refraction.",
		"prefix": "refract(direction, normal, index)",
		"scope": "source.vex"
	},
	"refractlight": {
		"body": "refractlight(${1:cf}, ${2:of}, ${3:af}, ${4:P}, ${5:N}, ${6:I}, ${7:eta}, ${8:bias}, ${9:max_contrib}${10:, ...})",
		"description": "Computes the illumination of surfaces refracted by the current\nsurface.",
		"prefix": "refractlight(cf, of, af, P, N, I, eta, bias, max_contrib, ...)",
		"scope": "source.vex"
	},
	"relativepath": {
		"body": "relativepath(${1:src}, ${2:dest})",
		"description": "Computes the relative path for two full paths.",
		"prefix": "relativepath(src, dest)",
		"scope": "source.vex"
	},
	"relbbox": {
		"body": "relbbox(${1:position})",
		"description": "Returns the relative position of the point given with respect to the bounding box of the geometry.",
		"prefix": "relbbox(position)",
		"scope": "source.vex"
	},
	"relpointbbox": {
		"body": "relpointbbox(${1:filename}, ${2:position})",
		"description": "Returns the relative position of the point given with respect to the bounding box of the geometry.",
		"prefix": "relpointbbox(filename, position)",
		"scope": "source.vex"
	},
	"removegroup": {
		"body": "removegroup(${1:group_name}, ${2:point_number})",
		"prefix": "removegroup(group_name, point_number)",
		"scope": "source.vex"
	},
	"removeindex": {
		"body": "removeindex(${1:array}, ${2:index})",
		"description": "Removes an item at the given index from an array.",
		"prefix": "removeindex(array, index)",
		"scope": "source.vex"
	},
	"removepoint": {
		"body": "removepoint(${1:geohandle}, ${2:point_number})",
		"description": "Removes a point from the geometry.",
		"prefix": "removepoint(geohandle, point_number)",
		"scope": "source.vex"
	},
	"removeprim": {
		"body": "removeprim(${1:geohandle}, ${2:prim_number}, ${3:andpoints})",
		"description": "Removes a primitive from the geometry.",
		"prefix": "removeprim(geohandle, prim_number, andpoints)",
		"scope": "source.vex"
	},
	"removevalue": {
		"body": "removevalue(${1:array}, ${2:value})",
		"description": "Removes an item from an array.",
		"prefix": "removevalue(array, value)",
		"scope": "source.vex"
	},
	"renderstate": {
		"body": "renderstate(${1:query}, ${2:value})",
		"description": "Queries the renderer for a named property.",
		"prefix": "renderstate(query, value)",
		"scope": "source.vex"
	},
	"reorder": {
		"body": "reorder(${1:value}, ${2:indices})",
		"description": "Reorders items in an array or string.",
		"prefix": "reorder(value, indices)",
		"scope": "source.vex"
	},
	"resample_linear": {
		"body": "resample_linear(${1:input}, ${2:new_length})",
		"description": "",
		"prefix": "resample_linear(input, new_length)",
		"scope": "source.vex"
	},
	"resize": {
		"body": "resize(${1:array}, ${2:size})",
		"description": "Sets the length of an array.",
		"prefix": "resize(array, size)",
		"scope": "source.vex"
	},
	"resolvemissedray": {
		"body": "resolvemissedray(${1:dir}, ${2:time}, ${3:mask}${4:, ...})",
		"description": "Returns the background color for rays that exit the scene.",
		"prefix": "resolvemissedray(dir, time, mask, ...)",
		"scope": "source.vex"
	},
	"reverse": {
		"body": "reverse(${1:value})",
		"description": "Returns an array or string in reverse order.",
		"prefix": "reverse(value)",
		"scope": "source.vex"
	},
	"rgbtohsv": {
		"body": "rgbtohsv(${1:hsv})",
		"description": "Convert RGB color space to HSV color space.",
		"prefix": "rgbtohsv(hsv)",
		"scope": "source.vex"
	},
	"rgbtoxyz": {
		"body": "rgbtoxyz(${1:rgb})",
		"description": "Convert a linear sRGB triplet to CIE XYZ tristimulus values.",
		"prefix": "rgbtoxyz(rgb)",
		"scope": "source.vex"
	},
	"rint": {
		"body": "rint(${1:value})",
		"description": "Rounds the number to the closest integer.",
		"prefix": "rint(value)",
		"scope": "source.vex"
	},
	"rotate": {
		"body": "rotate(${1:mat}, ${2:amount}, ${3:axis})",
		"description": "Applies a rotation to the given matrix.",
		"prefix": "rotate(mat, amount, axis)",
		"scope": "source.vex"
	},
	"rotate_x_to": {
		"body": "rotate_x_to(${1:direction}, ${2:v})",
		"description": "Rotates a vector by a rotation that would bring the x-axis to a given direction.",
		"prefix": "rotate_x_to(direction, v)",
		"scope": "source.vex"
	},
	"rstrip": {
		"body": "rstrip(${1:value}, ${2:whitespace})",
		"description": "Strips trailing whitespace from a string.",
		"prefix": "rstrip(value, whitespace)",
		"scope": "source.vex"
	},
	"sample_bsdf": {
		"body": "sample_bsdf(${1:b}, ${2:viewer}, ${3:out_vector}, ${4:eval}, ${5:type}, ${6:sx}, ${7:sy}${8:, ...})",
		"description": "Samples a bsdf.",
		"prefix": "sample_bsdf(b, viewer, out_vector, eval, type, sx, sy, ...)",
		"scope": "source.vex"
	},
	"sample_cauchy": {
		"body": "sample_cauchy(${1:origscale}, ${2:minvalue}, ${3:maxvalue}, ${4:u})",
		"description": "Samples the Cauchy (Lorentz) distribution.",
		"prefix": "sample_cauchy(origscale, minvalue, maxvalue, u)",
		"scope": "source.vex"
	},
	"sample_cdf": {
		"body": "sample_cdf(${1:cdf}, ${2:u}, ${3:index}, ${4:x}, ${5:pdf})",
		"description": "Samples a CDF based on a random variable.",
		"prefix": "sample_cdf(cdf, u, index, x, pdf)",
		"scope": "source.vex"
	},
	"sample_circle_arc": {
		"body": "sample_circle_arc(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform unit vector2, within maxangle of center, given a uniform number between 0 and 1.",
		"prefix": "sample_circle_arc(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_circle_edge_uniform": {
		"body": "sample_circle_edge_uniform(${1:u})",
		"description": "Generates a uniform unit vector2, given a uniform number between 0 and 1.",
		"prefix": "sample_circle_edge_uniform(u)",
		"scope": "source.vex"
	},
	"sample_circle_slice": {
		"body": "sample_circle_slice(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform vector2 with length &lt; 1, within maxangle of center, given a vector2 of uniform numbers between 0 and 1.",
		"prefix": "sample_circle_slice(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_circle_uniform": {
		"body": "sample_circle_uniform(${1:u})",
		"description": "Generates a uniform vector2 with length &lt; 1, given a vector2 of uniform numbers between 0 and 1.",
		"prefix": "sample_circle_uniform(u)",
		"scope": "source.vex"
	},
	"sample_direction_cone": {
		"body": "sample_direction_cone(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform unit vector, within maxangle of center, given a vector2 of uniform numbers between 0 and 1.",
		"prefix": "sample_direction_cone(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_direction_uniform": {
		"body": "sample_direction_uniform(${1:u})",
		"description": "Generates a uniform unit vector, given a vector2 of uniform numbers between 0 and 1.",
		"prefix": "sample_direction_uniform(u)",
		"scope": "source.vex"
	},
	"sample_discrete": {
		"body": "sample_discrete(${1:weights}, ${2:u})",
		"description": "Returns an integer, either uniform or weighted, given a uniform number between 0 and 1.",
		"prefix": "sample_discrete(weights, u)",
		"scope": "source.vex"
	},
	"sample_exponential": {
		"body": "sample_exponential(${1:origmean}, ${2:maxvalue}, ${3:u})",
		"description": "Samples the exponential distribution.",
		"prefix": "sample_exponential(origmean, maxvalue, u)",
		"scope": "source.vex"
	},
	"sample_geometry": {
		"body": "sample_geometry(${1:origin}, ${2:sample}, ${3:time}${4:, ...})",
		"description": "Samples geometry in the scene and returns information from the shaders of surfaces that were sampled.",
		"prefix": "sample_geometry(origin, sample, time, ...)",
		"scope": "source.vex"
	},
	"sample_hemisphere": {
		"body": "sample_hemisphere(${1:center}, ${2:u})",
		"description": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1.",
		"prefix": "sample_hemisphere(center, u)",
		"scope": "source.vex"
	},
	"sample_hypersphere_cone": {
		"body": "sample_hypersphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform vector4 with length &lt; 1, within maxangle of center, given a vector4 of uniform numbers between 0 and 1.",
		"prefix": "sample_hypersphere_cone(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_hypersphere_uniform": {
		"body": "sample_hypersphere_uniform(${1:u})",
		"description": "Generates a uniform vector4 with length &lt; 1, given a vector4 of uniform numbers between 0 and 1.",
		"prefix": "sample_hypersphere_uniform(u)",
		"scope": "source.vex"
	},
	"sample_light": {
		"body": "sample_light(${1:lightid}, ${2:pos}, ${3:sam}, ${4:time}, ${5:pos}, ${6:clr}, ${7:scale}${8:, ...})",
		"description": "Samples a 3D position on a light source and runs the light shader at that point.",
		"prefix": "sample_light(lightid, pos, sam, time, pos, clr, scale, ...)",
		"scope": "source.vex"
	},
	"sample_lognormal": {
		"body": "sample_lognormal(${1:mu}, ${2:sigma}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
		"description": "Samples the log-normal distribution based on parameters of the underlying normal distribution.",
		"prefix": "sample_lognormal(mu, sigma, minvalue, maxvalue, u)",
		"scope": "source.vex"
	},
	"sample_lognormal_by_median": {
		"body": "sample_lognormal_by_median(${1:origmedian}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
		"description": "Samples the log-normal distribution based on median and standard deviation.",
		"prefix": "sample_lognormal_by_median(origmedian, origstddev, minvalue, maxvalue, u)",
		"scope": "source.vex"
	},
	"sample_normal": {
		"body": "sample_normal(${1:origmean}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
		"description": "Samples the normal (Gaussian) distribution.",
		"prefix": "sample_normal(origmean, origstddev, minvalue, maxvalue, u)",
		"scope": "source.vex"
	},
	"sample_orientation_cone": {
		"body": "sample_orientation_cone(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform unit vector4, within maxangle of center, given a vector of uniform numbers between 0 and 1.",
		"prefix": "sample_orientation_cone(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_orientation_uniform": {
		"body": "sample_orientation_uniform(${1:u})",
		"description": "Generates a uniform unit vector4, given a vector of uniform numbers between 0 and 1.",
		"prefix": "sample_orientation_uniform(u)",
		"scope": "source.vex"
	},
	"sample_photon": {
		"body": "sample_photon(${1:lp}, ${2:pos}, ${3:dir}, ${4:scale}, ${5:time})",
		"description": "Samples a 3D position on a light source and runs the light shader at that point.",
		"prefix": "sample_photon(lp, pos, dir, scale, time)",
		"scope": "source.vex"
	},
	"sample_sphere_cone": {
		"body": "sample_sphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
		"description": "Generates a uniform vector with length &lt; 1, within maxangle of center, given a vector of uniform numbers between 0 and 1.",
		"prefix": "sample_sphere_cone(center, maxangle, u)",
		"scope": "source.vex"
	},
	"sample_sphere_uniform": {
		"body": "sample_sphere_uniform(${1:u})",
		"description": "Generates a uniform vector with length &lt; 1, given a vector of uniform numbers between 0 and 1.",
		"prefix": "sample_sphere_uniform(u)",
		"scope": "source.vex"
	},
	"sampledisk": {
		"body": "sampledisk(${1:x}, ${2:y}, ${3:sx}, ${4:sy})",
		"description": "Warps uniform random samples to a disk.",
		"prefix": "sampledisk(x, y, sx, sy)",
		"scope": "source.vex"
	},
	"scale": {
		"body": "scale(${1:mat}, ${2:scale_vector})",
		"description": "Scales the given matrix in three directions simultaneously (X, Y, Z -\ngiven by the components of the scale_vector).",
		"prefix": "scale(mat, scale_vector)",
		"scope": "source.vex"
	},
	"scatter": {
		"body": "scatter(${1:ipoint}, ${2:inormal}, ${3:idirection}, ${4:idistribution}, ${5:time}, ${6:maxdist}, ${7:opoint}, ${8:onormal}, ${9:odirection})",
		"description": "Evaluates a scattering event through the domain of a geometric object.",
		"prefix": "scatter(ipoint, inormal, idirection, idistribution, time, maxdist, opoint, onormal, odirection)",
		"scope": "source.vex"
	},
	"select": {
		"body": "select(${1:conditional}, ${2:a}, ${3:b})",
		"description": "Returns one of two parameters based on a conditional.",
		"prefix": "select(conditional, a, b)",
		"scope": "source.vex"
	},
	"sensor_panorama_create": {
		"body": "sensor_panorama_create(${1:time}, ${2:pos}, ${3:size}, ${4:near}, ${5:far}, ${6:candidateobj}, ${7:includeobj}, ${8:excludeobj}, ${9:uselit})",
		"description": "Sensor function to render GL scene and query the result.",
		"prefix": "sensor_panorama_create(time, pos, size, near, far, candidateobj, includeobj, excludeobj, uselit)",
		"scope": "source.vex"
	},
	"sensor_panorama_getcolor": {
		"body": "sensor_panorama_getcolor(${1:handle}, ${2:dir})",
		"description": "Sensor function query a rendered GL scene.",
		"prefix": "sensor_panorama_getcolor(handle, dir)",
		"scope": "source.vex"
	},
	"sensor_panorama_getcone": {
		"body": "sensor_panorama_getcone(${1:handle}, ${2:lookodir}, ${3:angle}, ${4:colormin}, ${5:colormax}, ${6:depthmin}, ${7:depthmax}, ${8:strength}, ${9:dir}, ${10:color}, ${11:depth})",
		"description": "Sensor function to query average values from rendered GL scene.",
		"prefix": "sensor_panorama_getcone(handle, lookodir, angle, colormin, colormax, depthmin, depthmax, strength, dir, color, depth)",
		"scope": "source.vex"
	},
	"sensor_panorama_getdepth": {
		"body": "sensor_panorama_getdepth(${1:handle}, ${2:dir})",
		"description": "Sensor function query a rendered GL scene.",
		"prefix": "sensor_panorama_getdepth(handle, dir)",
		"scope": "source.vex"
	},
	"sensor_save": {
		"body": "sensor_save(${1:handle}, ${2:colorfile}, ${3:depthfile})",
		"description": "Sensor function to save a rendered GL scene.",
		"prefix": "sensor_save(handle, colorfile, depthfile)",
		"scope": "source.vex"
	},
	"serialize": {
		"body": "serialize(${1:array})",
		"description": "Flattens an array of vector or matrix types into an array of floats.",
		"prefix": "serialize(array)",
		"scope": "source.vex"
	},
	"set": {
		"body": "set(${1:x}, ${2:y}, ${3:z})",
		"description": "These two functions provide a very efficient way of creating a\nvector/vector4.",
		"prefix": "set(x, y, z)",
		"scope": "source.vex"
	},
	"setagentclipnames": {
		"body": "setagentclipnames(${1:geohandle}, ${2:prim}, ${3:clipnames})",
		"description": "Sets the current animation clips for an agent primitive.",
		"prefix": "setagentclipnames(geohandle, prim, clipnames)",
		"scope": "source.vex"
	},
	"setagentclips": {
		"body": "setagentclips(${1:geohandle}, ${2:prim}, ${3:clip_names}, ${4:clip_times}, ${5:clip_weights}, ${6:clip_transform_groups}, ${7:clip_layer_ids}, ${8:layer_blend_modes}, ${9:layer_weights}, ${10:layer_parent_ids})",
		"description": "Sets the animation clips that an agent should use to compute its transforms.",
		"prefix": "setagentclips(geohandle, prim, clip_names, clip_times, clip_weights, clip_transform_groups, clip_layer_ids, layer_blend_modes, layer_weights, layer_parent_ids)",
		"scope": "source.vex"
	},
	"setagentcliptimes": {
		"body": "setagentcliptimes(${1:geohandle}, ${2:prim}, ${3:cliptimes})",
		"description": "Sets the current times for an agent primitive\u2019s animation clips.",
		"prefix": "setagentcliptimes(geohandle, prim, cliptimes)",
		"scope": "source.vex"
	},
	"setagentclipweights": {
		"body": "setagentclipweights(${1:geohandle}, ${2:prim}, ${3:clipweights})",
		"description": "Sets the blend weights for an agent primitive\u2019s animation clips.",
		"prefix": "setagentclipweights(geohandle, prim, clipweights)",
		"scope": "source.vex"
	},
	"setagentcollisionlayer": {
		"body": "setagentcollisionlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
		"description": "Sets the collision layer of an agent primitive.",
		"prefix": "setagentcollisionlayer(geohandle, prim, layername)",
		"scope": "source.vex"
	},
	"setagentcurrentlayer": {
		"body": "setagentcurrentlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
		"description": "Sets the current layer of an agent primitive.",
		"prefix": "setagentcurrentlayer(geohandle, prim, layername)",
		"scope": "source.vex"
	},
	"setagentlocaltransform": {
		"body": "setagentlocaltransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
		"description": "Overrides the local space transform of an agent primitive\u2019s bone.",
		"prefix": "setagentlocaltransform(geohandle, prim, transform, index)",
		"scope": "source.vex"
	},
	"setagentlocaltransforms": {
		"body": "setagentlocaltransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
		"description": "Overrides the local space transforms of an agent primitive.",
		"prefix": "setagentlocaltransforms(geohandle, prim, transforms)",
		"scope": "source.vex"
	},
	"setagentworldtransform": {
		"body": "setagentworldtransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
		"description": "Overrides the world space transform of an agent primitive\u2019s bone.",
		"prefix": "setagentworldtransform(geohandle, prim, transform, index)",
		"scope": "source.vex"
	},
	"setagentworldtransforms": {
		"body": "setagentworldtransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
		"description": "Overrides the world space transforms of an agent primitive.",
		"prefix": "setagentworldtransforms(geohandle, prim, transforms)",
		"scope": "source.vex"
	},
	"setattrib": {
		"body": "setattrib(${1:geohandle}, ${2:attribclass}, ${3:name}, ${4:elemnum}, ${5:vtxofprim}, ${6:value}, ${7:mode=\"set\"})",
		"description": "Writes an attribute value to geometry.",
		"prefix": "setattrib(geohandle, attribclass, name, elemnum, vtxofprim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setattribtypeinfo": {
		"body": "setattribtypeinfo(${1:geohandle}, ${2:attribtype}, ${3:name}, ${4:typeinfo})",
		"description": "Sets the meaning of an attribute in geometry.",
		"prefix": "setattribtypeinfo(geohandle, attribtype, name, typeinfo)",
		"scope": "source.vex"
	},
	"setcomp": {
		"body": "setcomp(${1:target}, ${2:value}, ${3:index})",
		"description": "Sets a single component of a vector type, matrix type, or array.",
		"prefix": "setcomp(target, value, index)",
		"scope": "source.vex"
	},
	"setcurrentlight": {
		"body": "setcurrentlight(${1:lightid})",
		"description": "Sets the current light",
		"prefix": "setcurrentlight(lightid)",
		"scope": "source.vex"
	},
	"setdetailattrib": {
		"body": "setdetailattrib(${1:geohandle}, ${2:name}, ${3:value}, ${4:mode=\"set\"})",
		"description": "Sets a detail attribute in a geometry.",
		"prefix": "setdetailattrib(geohandle, name, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setpointattrib": {
		"body": "setpointattrib(${1:geohandle}, ${2:name}, ${3:pt}, ${4:value}, ${5:mode=\"set\"})",
		"description": "Sets a point attribute in a geometry.",
		"prefix": "setpointattrib(geohandle, name, pt, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setpointgroup": {
		"body": "setpointgroup(${1:geohandle}, ${2:name}, ${3:pt}, ${4:value}, ${5:mode=\"set\"})",
		"description": "Sets point group membership in a geometry.",
		"prefix": "setpointgroup(geohandle, name, pt, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setprimattrib": {
		"body": "setprimattrib(${1:geohandle}, ${2:name}, ${3:prim}, ${4:value}, ${5:mode=\"set\"})",
		"description": "Sets a primitive attribute in a geometry.",
		"prefix": "setprimattrib(geohandle, name, prim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setprimgroup": {
		"body": "setprimgroup(${1:geohandle}, ${2:name}, ${3:prim}, ${4:value}, ${5:mode=\"set\"})",
		"description": "Sets primitive group membership in a geometry.",
		"prefix": "setprimgroup(geohandle, name, prim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setprimintrinsic": {
		"body": "setprimintrinsic(${1:geohandle}, ${2:name}, ${3:prim}, ${4:value}, ${5:mode=\"set\"})",
		"description": "Sets a primitive intrinsic value in a geometry.",
		"prefix": "setprimintrinsic(geohandle, name, prim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setprimvertex": {
		"body": "setprimvertex(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
		"description": "Rewires a vertex in the geometry to a different point.",
		"prefix": "setprimvertex(geohandle, prim, vtxofprim, pt)",
		"scope": "source.vex"
	},
	"setsamplestore": {
		"body": "setsamplestore(${1:channel}, ${2:P}, ${3:value})",
		"description": "Stores sample data in a channel, referenced by a point.",
		"prefix": "setsamplestore(channel, P, value)",
		"scope": "source.vex"
	},
	"setvertexattrib": {
		"body": "setvertexattrib(${1:geohandle}, ${2:name}, ${3:elemnum}, ${4:vtxofprim}, ${5:value}, ${6:mode=\"set\"})",
		"description": "Sets a vertex attribute in a geometry.",
		"prefix": "setvertexattrib(geohandle, name, elemnum, vtxofprim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setvertexgroup": {
		"body": "setvertexgroup(${1:geohandle}, ${2:name}, ${3:elemnum}, ${4:vtxofprim}, ${5:value}, ${6:mode=\"set\"})",
		"description": "Sets vertex group membership in a geometry.",
		"prefix": "setvertexgroup(geohandle, name, elemnum, vtxofprim, value, mode=\"set\")",
		"scope": "source.vex"
	},
	"setvertexpoint": {
		"body": "setvertexpoint(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
		"description": "Rewires a vertex in the geometry to a different point.",
		"prefix": "setvertexpoint(geohandle, prim, vtxofprim, pt)",
		"scope": "source.vex"
	},
	"shadow": {
		"body": "shadow(${1:Cl}, ${2:P}, ${3:L})",
		"description": "Calls shadow shaders for the current light source.",
		"prefix": "shadow(Cl, P, L)",
		"scope": "source.vex"
	},
	"shadow_light": {
		"body": "shadow_light(${1:lightid}, ${2:pos}, ${3:dir}, ${4:time}${5:, ...})",
		"description": "Executes the shadow shader for a given light and returns the amount of shadowing as a multiplier of the shaded color.",
		"prefix": "shadow_light(lightid, pos, dir, time, ...)",
		"scope": "source.vex"
	},
	"shadowmap": {
		"body": "shadowmap(${1:filename}, ${2:rect1}, ${3:rect2}, ${4:rect3}, ${5:rect4}, ${6:spread}, ${7:bias}, ${8:quality}${9:, ...})",
		"description": "The shadowmap function will treat the shadow map as if the image were\nrendered from a light source.",
		"prefix": "shadowmap(filename, rect1, rect2, rect3, rect4, spread, bias, quality, ...)",
		"scope": "source.vex"
	},
	"shimport": {
		"body": "shimport(${1:name}, ${2:value})",
		"description": "Imports a variable from the shadow shader for the surface.",
		"prefix": "shimport(name, value)",
		"scope": "source.vex"
	},
	"shl": {
		"body": "shl(${1:a}, ${2:bits})",
		"description": "Bit-shifts an integer left.",
		"prefix": "shl(a, bits)",
		"scope": "source.vex"
	},
	"shr": {
		"body": "shr(${1:a}, ${2:bits})",
		"description": "Bit-shifts an integer right.",
		"prefix": "shr(a, bits)",
		"scope": "source.vex"
	},
	"shrz": {
		"body": "shrz(${1:a}, ${2:bits})",
		"description": "Bit-shifts an integer right.",
		"prefix": "shrz(a, bits)",
		"scope": "source.vex"
	},
	"sign": {
		"body": "sign(${1:value})",
		"description": "Returns the sign of the argument.",
		"prefix": "sign(value)",
		"scope": "source.vex"
	},
	"simport": {
		"body": "simport(${1:name}, ${2:value})",
		"description": "Imports a variable sent by a surface shader in an illuminance loop.",
		"prefix": "simport(name, value)",
		"scope": "source.vex"
	},
	"sin": {
		"body": "sin(${1:value})",
		"description": "Returns the sine of the argument.",
		"prefix": "sin(value)",
		"scope": "source.vex"
	},
	"sinh": {
		"body": "sinh(${1:value})",
		"description": "Returns the hyperbolic sine of the argument.",
		"prefix": "sinh(value)",
		"scope": "source.vex"
	},
	"sleep": {
		"body": "sleep(${1:milliseconds})",
		"description": "Yields processing for a certain number of milliseconds.",
		"prefix": "sleep(milliseconds)",
		"scope": "source.vex"
	},
	"slerp": {
		"body": "slerp(${1:q1}, ${2:q2}, ${3:bias})",
		"description": "Quaternion blend between q1 and q2 based on the bias.",
		"prefix": "slerp(q1, q2, bias)",
		"scope": "source.vex"
	},
	"slice": {
		"body": "slice(${1:s}, ${2:hasstart}, ${3:start}, ${4:hasend}, ${5:end}, ${6:hasstep}, ${7:step})",
		"description": "Slices a sub-string or sub-array of a string or array.",
		"prefix": "slice(s, hasstart, start, hasend, end, hasstep, step)",
		"scope": "source.vex"
	},
	"slideframe": {
		"body": "slideframe(${1:x0}, ${2:t0}, ${3:n0}, ${4:x1}, ${5:t1})",
		"description": "Finds the normal component of frame slid along a curve. ",
		"prefix": "slideframe(x0, t0, n0, x1, t1)",
		"scope": "source.vex"
	},
	"smooth": {
		"body": "smooth(${1:value1}, ${2:value2}, ${3:amount}, ${4:rolloff})",
		"description": "Computes a number between zero and one.",
		"prefix": "smooth(value1, value2, amount, rolloff)",
		"scope": "source.vex"
	},
	"smoothrotation": {
		"body": "smoothrotation(${1:order}, ${2:r}, ${3:r_reference})",
		"description": "Returns the closest equivalent Euler rotations to a reference rotation.",
		"prefix": "smoothrotation(order, r, r_reference)",
		"scope": "source.vex"
	},
	"snoise": {
		"body": "snoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
		"description": "These functions are similar to wnoise.",
		"prefix": "snoise(pos, turbulence, rough, atten)",
		"scope": "source.vex"
	},
	"solid_angle": {
		"body": "solid_angle(${1:b}, ${2:mask})",
		"description": "Computes the solid angle (in steradians) a bsdf\u2019s function subtends.",
		"prefix": "solid_angle(b, mask)",
		"scope": "source.vex"
	},
	"solvecubic": {
		"body": "solvecubic(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:t1}, ${6:t2}, ${7:t3})",
		"description": "Solves a cubic function returning the number of real roots.",
		"prefix": "solvecubic(a, b, c, d, t1, t2, t3)",
		"scope": "source.vex"
	},
	"solvepoly": {
		"body": "solvepoly(${1:coef}, ${2:root}, ${3:maxiter})",
		"description": "Finds the real roots of a polynomial.",
		"prefix": "solvepoly(coef, root, maxiter)",
		"scope": "source.vex"
	},
	"solvequadratic": {
		"body": "solvequadratic(${1:a}, ${2:b}, ${3:c}, ${4:t1}, ${5:t2})",
		"description": "Solves a quadratic function returning the number of real roots.",
		"prefix": "solvequadratic(a, b, c, t1, t2)",
		"scope": "source.vex"
	},
	"sort": {
		"body": "sort(${1:value})",
		"description": "Returns the array sorted in increasing order.",
		"prefix": "sort(value)",
		"scope": "source.vex"
	},
	"specular": {
		"body": "specular(${1:nml}, ${2:V}, ${3:roughness}${4:, ...})",
		"description": "Returns the illumination for specular highlights using different lighting models.",
		"prefix": "specular(nml, V, roughness, ...)",
		"scope": "source.vex"
	},
	"specularBRDF": {
		"body": "specularBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
		"description": "Returns the computed BRDFs for the different lighting models used in VEX shading.",
		"prefix": "specularBRDF(L, N, V, rough)",
		"scope": "source.vex"
	},
	"spline": {
		"body": "spline(${1:bases}, ${2:coord}, ${3:values}, ${4:knots}${5:, ...})",
		"description": "Returns an interpolated value along a polyline or spline curve.",
		"prefix": "spline(bases, coord, values, knots, ...)",
		"scope": "source.vex"
	},
	"split": {
		"body": "split(${1:s}, ${2:separators}, ${3:maxsplits})",
		"description": "Splits a string into tokens.",
		"prefix": "split(s, separators, maxsplits)",
		"scope": "source.vex"
	},
	"split_bsdf": {
		"body": "split_bsdf(${1:lobes}, ${2:b}, ${3:weights})",
		"description": "Splits a bsdf into it\u2019s component lobes.",
		"prefix": "split_bsdf(lobes, b, weights)",
		"scope": "source.vex"
	},
	"splitpath": {
		"body": "splitpath(${1:fullpath}, ${2:dir}, ${3:name})",
		"description": "Splits a file path into the directory and name parts.",
		"prefix": "splitpath(fullpath, dir, name)",
		"scope": "source.vex"
	},
	"sprintf": {
		"body": "sprintf(${1:format}${2:, ...})",
		"description": "Formats a string like printf but returns the result as a string\ninstead of printing it.",
		"prefix": "sprintf(format, ...)",
		"scope": "source.vex"
	},
	"sqrt": {
		"body": "sqrt(${1:value})",
		"description": "Returns the square root of the argument.",
		"prefix": "sqrt(value)",
		"scope": "source.vex"
	},
	"sssapprox": {
		"body": "sssapprox(${1:albedo}, ${2:meanFreePath}, ${3:roughness}, ${4:scale}${5:, ...})",
		"description": "Creates an approximate SSS BSDF.",
		"prefix": "sssapprox(albedo, meanFreePath, roughness, scale, ...)",
		"scope": "source.vex"
	},
	"startswith": {
		"body": "startswith(${1:str}, ${2:startswith})",
		"description": "Returns 1 if the string starts with the specified string.",
		"prefix": "startswith(str, startswith)",
		"scope": "source.vex"
	},
	"storelightexport": {
		"body": "storelightexport(${1:lightname}, ${2:exportname}, ${3:value})",
		"description": "Stores exported data for a light.",
		"prefix": "storelightexport(lightname, exportname, value)",
		"scope": "source.vex"
	},
	"strip": {
		"body": "strip(${1:value}, ${2:whitespace})",
		"description": "Strips leading and trailing whitespace from a string.",
		"prefix": "strip(value, whitespace)",
		"scope": "source.vex"
	},
	"strlen": {
		"body": "strlen(${1:string})",
		"description": "Returns the length of the string.",
		"prefix": "strlen(string)",
		"scope": "source.vex"
	},
	"sum": {
		"body": "sum(${1:v})",
		"description": "Returns the sum of the vector\u2019s components.",
		"prefix": "sum(v)",
		"scope": "source.vex"
	},
	"switch": {
		"body": "switch(${1:direct}, ${2:indirect})",
		"description": "Use a different bsdf for direct or indirect lighting.",
		"prefix": "switch(direct, indirect)",
		"scope": "source.vex"
	},
	"swizzle": {
		"body": "swizzle(${1:xyz}, ${2:i0}, ${3:i1}, ${4:i2})",
		"description": "Rearranges components of a vector.",
		"prefix": "swizzle(xyz, i0, i1, i2)",
		"scope": "source.vex"
	},
	"tan": {
		"body": "tan(${1:value})",
		"description": "Returns the trigonometric tangent of the argument",
		"prefix": "tan(value)",
		"scope": "source.vex"
	},
	"tanh": {
		"body": "tanh(${1:value})",
		"description": "Returns the hyperbolic tangent of the argument",
		"prefix": "tanh(value)",
		"scope": "source.vex"
	},
	"tet_adjacent": {
		"body": "tet_adjacent(${1:geometry}, ${2:primindex}, ${3:faceno})",
		"description": "Returns primitive number of an adjacent tetrahedron.",
		"prefix": "tet_adjacent(geometry, primindex, faceno)",
		"scope": "source.vex"
	},
	"tet_faceindex": {
		"body": "tet_faceindex(${1:faceno}, ${2:vtxno})",
		"description": "Returns vertex indices of each face of a tetrahedron.",
		"prefix": "tet_faceindex(faceno, vtxno)",
		"scope": "source.vex"
	},
	"teximport": {
		"body": "teximport(${1:map}, ${2:attribute}, ${3:value})",
		"description": "Imports attributes from texture files.",
		"prefix": "teximport(map, attribute, value)",
		"scope": "source.vex"
	},
	"texprintf": {
		"body": "texprintf(${1:u}, ${2:v}, ${3:format}${4:, ...})",
		"description": "Similar to sprintf, but does expansion of UDIM or UVTILE texture filename expansion.",
		"prefix": "texprintf(u, v, format, ...)",
		"scope": "source.vex"
	},
	"texture": {
		"body": "texture(${1:map}, ${2:s0}, ${3:t0}, ${4:s1}, ${5:t1}, ${6:s2}, ${7:t2}, ${8:s3}, ${9:t3}${10:, ...})",
		"description": "Computes a filtered sample of the texture map specified.",
		"prefix": "texture(map, s0, t0, s1, t1, s2, t2, s3, t3, ...)",
		"scope": "source.vex"
	},
	"texture3d": {
		"body": "texture3d(${1:filename}, ${2:channel}, ${3:P}${4:, ...})",
		"description": "Returns the value of the 3d image at the position specified by P.",
		"prefix": "texture3d(filename, channel, P, ...)",
		"scope": "source.vex"
	},
	"texture3dBox": {
		"body": "texture3dBox(${1:filename}, ${2:channel}, ${3:min}, ${4:max}${5:, ...})",
		"description": "This function queries the 3D texture map specified and returns the\nbounding box information of the file.",
		"prefix": "texture3dBox(filename, channel, min, max, ...)",
		"scope": "source.vex"
	},
	"titlecase": {
		"body": "titlecase(${1:str})",
		"description": "Returns a string that is the titlecase version of the input string.",
		"prefix": "titlecase(str)",
		"scope": "source.vex"
	},
	"toNDC": {
		"body": "toNDC(${1:point})",
		"description": "Transforms a position into normal device coordinates.",
		"prefix": "toNDC(point)",
		"scope": "source.vex"
	},
	"tolower": {
		"body": "tolower(${1:str})",
		"description": "Converts all charactors in string to lower case",
		"prefix": "tolower(str)",
		"scope": "source.vex"
	},
	"toupper": {
		"body": "toupper(${1:str})",
		"description": "Convers all charactors in string to upper case",
		"prefix": "toupper(str)",
		"scope": "source.vex"
	},
	"trace": {
		"body": "trace(${1:cv}, ${2:of}, ${3:af}, ${4:P}, ${5:D}, ${6:shadow_bias}, ${7:max_contrib}${8:, ...})",
		"description": "Sends a ray from P along the normalized vector D.",
		"prefix": "trace(cv, of, af, P, D, shadow_bias, max_contrib, ...)",
		"scope": "source.vex"
	},
	"translate": {
		"body": "translate(${1:mat}, ${2:amount})",
		"description": "Translates the given matrix.",
		"prefix": "translate(mat, amount)",
		"scope": "source.vex"
	},
	"translucent": {
		"body": "translucent(${1:nml}, ${2:ng}${3:, ...})",
		"description": "Returns the lambertian translucence given the surface normal.",
		"prefix": "translucent(nml, ng, ...)",
		"scope": "source.vex"
	},
	"transpose": {
		"body": "transpose(${1:mat})",
		"description": "Transposes the given matrix.",
		"prefix": "transpose(mat)",
		"scope": "source.vex"
	},
	"trunc": {
		"body": "trunc(${1:x})",
		"description": "If the argument is negative, this returns ceil(x), otherwise it returns floor(x).",
		"prefix": "trunc(x)",
		"scope": "source.vex"
	},
	"tw_nspace": {
		"body": "tw_nspace(${1:n})",
		"description": "Transforms a normal vector from Texture to World space.",
		"prefix": "tw_nspace(n)",
		"scope": "source.vex"
	},
	"tw_space": {
		"body": "tw_space(${1:v})",
		"description": "Transforms a position value from Texture to World space.",
		"prefix": "tw_space(v)",
		"scope": "source.vex"
	},
	"tw_vspace": {
		"body": "tw_vspace(${1:v})",
		"description": "Transforms a direction vector from Texture to World space.",
		"prefix": "tw_vspace(v)",
		"scope": "source.vex"
	},
	"uniqueval": {
		"body": "uniqueval(${1:file}, ${2:class}, ${3:attribute_name}, ${4:which})",
		"description": "Returns a unique value from an integer or string attribute.",
		"prefix": "uniqueval(file, class, attribute_name, which)",
		"scope": "source.vex"
	},
	"unpack_intfromsafefloat": {
		"body": "unpack_intfromsafefloat(${1:value})",
		"description": "Reverses the packing of pack_inttosafefloat to get back the original integer.",
		"prefix": "unpack_intfromsafefloat(value)",
		"scope": "source.vex"
	},
	"unserialize": {
		"body": "unserialize(${1:array})",
		"description": "Turns a flat array of floats into an array of vectors or matrices.",
		"prefix": "unserialize(array)",
		"scope": "source.vex"
	},
	"upush": {
		"body": "upush(${1:array}, ${2:value})",
		"description": "Adds a uniform item to an array.",
		"prefix": "upush(array, value)",
		"scope": "source.vex"
	},
	"uvdist": {
		"body": "uvdist(${1:geometry}, ${2:uvname}, ${3:uv}, ${4:prim}, ${5:primuv}, ${6:maxdist})",
		"description": "Finds the distance of a uv coordinate to a geometry in uv space.",
		"prefix": "uvdist(geometry, uvname, uv, prim, primuv, maxdist)",
		"scope": "source.vex"
	},
	"uvintersect": {
		"body": "uvintersect(${1:filename}, ${2:uvname}, ${3:orig}, ${4:dir}, ${5:pos}, ${6:primuv})",
		"description": "This function computes the intersection of the specified ray with the geometry in uv space.",
		"prefix": "uvintersect(filename, uvname, orig, dir, pos, primuv)",
		"scope": "source.vex"
	},
	"uvsample": {
		"body": "uvsample(${1:filename}, ${2:att}, ${3:uvname}, ${4:uv})",
		"description": "Evaluates an attribute on a geometry using a uv attribute name and value.",
		"prefix": "uvsample(filename, att, uvname, uv)",
		"scope": "source.vex"
	},
	"uvunwrap": {
		"body": "uvunwrap(${1:undocumented}, ${2:u}, ${3:v}, ${4:time}, ${5:undocumented}, ${6:undocumented}, ${7:undocumented}, ${8:undocumented})",
		"description": "Computes the position and normal of an object given a (u, v) coordinate",
		"prefix": "uvunwrap(undocumented, u, v, time, undocumented, undocumented, undocumented, undocumented)",
		"scope": "source.vex"
	},
	"variance": {
		"body": "variance(${1:variable}, ${2:mean}, ${3:sample_size})",
		"description": "Computes the mean value and variance for a value.",
		"prefix": "variance(variable, mean, sample_size)",
		"scope": "source.vex"
	},
	"velocityname": {
		"body": "velocityname()",
		"description": "Returns the default name of the velocity plane (as it appears in the\ncompositor preferences).",
		"prefix": "velocityname()",
		"scope": "source.vex"
	},
	"vertex": {
		"body": "vertex(${1:geometry}, ${2:attribute_name}, ${3:prim}, ${4:vertex})",
		"description": "Imports a vertex attribute value from a geometry.",
		"prefix": "vertex(geometry, attribute_name, prim, vertex)",
		"scope": "source.vex"
	},
	"vertexattrib": {
		"body": "vertexattrib(${1:geometry}, ${2:attribute_name}, ${3:linearvertex}, ${4:success})",
		"description": "Imports a vertex attribute value from a geometry.",
		"prefix": "vertexattrib(geometry, attribute_name, linearvertex, success)",
		"scope": "source.vex"
	},
	"vertexattribsize": {
		"body": "vertexattribsize(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the size of a geometry vertex attribute.",
		"prefix": "vertexattribsize(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"vertexattribtype": {
		"body": "vertexattribtype(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type of a geometry vertex attribute.",
		"prefix": "vertexattribtype(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"vertexattribtypeinfo": {
		"body": "vertexattribtypeinfo(${1:geometry}, ${2:attribute_name})",
		"description": "Returns the type info of a geometry attribute.",
		"prefix": "vertexattribtypeinfo(geometry, attribute_name)",
		"scope": "source.vex"
	},
	"vertexhedge": {
		"body": "vertexhedge(${1:geometry}, ${2:vertex})",
		"description": "Returns the half-edge which has a vertex as source.",
		"prefix": "vertexhedge(geometry, vertex)",
		"scope": "source.vex"
	},
	"vertexindex": {
		"body": "vertexindex(${1:geometry}, ${2:primnum}, ${3:vertex})",
		"description": "Converts a primitive/vertex pair into a linear vertex.",
		"prefix": "vertexindex(geometry, primnum, vertex)",
		"scope": "source.vex"
	},
	"vertexnext": {
		"body": "vertexnext(${1:geometry}, ${2:linearvertex})",
		"description": "Returns the linear vertex number of next shared vertex in a geometry.",
		"prefix": "vertexnext(geometry, linearvertex)",
		"scope": "source.vex"
	},
	"vertexpoint": {
		"body": "vertexpoint(${1:geometry}, ${2:linearvertex})",
		"description": "Returns the point number of linear vertex in a geometry.",
		"prefix": "vertexpoint(geometry, linearvertex)",
		"scope": "source.vex"
	},
	"vertexprev": {
		"body": "vertexprev(${1:geometry}, ${2:linearvertex})",
		"description": "Returns the linear vertex number of previous shared vertex in a geometry.",
		"prefix": "vertexprev(geometry, linearvertex)",
		"scope": "source.vex"
	},
	"vertexprim": {
		"body": "vertexprim(${1:geometry}, ${2:linearvertex})",
		"description": "Returns the primitive number of a linear vertex in a geometry.",
		"prefix": "vertexprim(geometry, linearvertex)",
		"scope": "source.vex"
	},
	"vertexprimindex": {
		"body": "vertexprimindex(${1:geometry}, ${2:linearvertexnum})",
		"description": "Converts a linear vertex number into a vertex number within that primitive.",
		"prefix": "vertexprimindex(geometry, linearvertexnum)",
		"scope": "source.vex"
	},
	"vnoise": {
		"body": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos1}, ${8:period})",
		"description": "Voronoi noise gives almost identical results to the Worley noise\nfunctions.",
		"prefix": "vnoise(position, jitter, seed, f1, f2, pos1, pos1, period)",
		"scope": "source.vex"
	},
	"volume": {
		"body": "volume(${1:pos}${2:, ...})",
		"description": "Returns the volume of the microvoxel containing a variable such as P.",
		"prefix": "volume(pos, ...)",
		"scope": "source.vex"
	},
	"volumegradient": {
		"body": "volumegradient(${1:filename}, ${2:volumename}, ${3:pos})",
		"description": "Calculates the volume primitive\u2019s gradient.",
		"prefix": "volumegradient(filename, volumename, pos)",
		"scope": "source.vex"
	},
	"volumeindex": {
		"body": "volumeindex(${1:filename}, ${2:volumename}, ${3:voxel})",
		"description": "Gets the value of a specific voxel.",
		"prefix": "volumeindex(filename, volumename, voxel)",
		"scope": "source.vex"
	},
	"volumeindexorigin": {
		"body": "volumeindexorigin(${1:filename}, ${2:volumename})",
		"description": "Gets the index of the bottom left of a volume primitive.",
		"prefix": "volumeindexorigin(filename, volumename)",
		"scope": "source.vex"
	},
	"volumeindextopos": {
		"body": "volumeindextopos(${1:filename}, ${2:volumename}, ${3:voxel})",
		"description": "Converts a volume voxel index into a position.",
		"prefix": "volumeindextopos(filename, volumename, voxel)",
		"scope": "source.vex"
	},
	"volumeindexv": {
		"body": "volumeindexv(${1:filename}, ${2:volumename}, ${3:voxel})",
		"description": "Gets the vector value of a specific voxel.",
		"prefix": "volumeindexv(filename, volumename, voxel)",
		"scope": "source.vex"
	},
	"volumepostoindex": {
		"body": "volumepostoindex(${1:filename}, ${2:volumename}, ${3:position})",
		"description": "Converts a position into a volume voxel index.",
		"prefix": "volumepostoindex(filename, volumename, position)",
		"scope": "source.vex"
	},
	"volumeres": {
		"body": "volumeres(${1:filename}, ${2:volumename})",
		"description": "Gets the resolution of a volume primitive.",
		"prefix": "volumeres(filename, volumename)",
		"scope": "source.vex"
	},
	"volumesample": {
		"body": "volumesample(${1:filename}, ${2:volumename}, ${3:pos})",
		"description": "Samples the volume primitive\u2019s value.",
		"prefix": "volumesample(filename, volumename, pos)",
		"scope": "source.vex"
	},
	"volumesamplev": {
		"body": "volumesamplev(${1:filename}, ${2:volumename}, ${3:pos})",
		"description": "Samples the volume primitive\u2019s vector value.",
		"prefix": "volumesamplev(filename, volumename, pos)",
		"scope": "source.vex"
	},
	"volumevoxeldiameter": {
		"body": "volumevoxeldiameter(${1:geofile}, ${2:primname})",
		"description": "Computes the approximate diameter of a voxel.",
		"prefix": "volumevoxeldiameter(geofile, primname)",
		"scope": "source.vex"
	},
	"vtransform": {
		"body": "vtransform(${1:v}, ${2:transform_matrix})",
		"description": "See ptransform.",
		"prefix": "vtransform(v, transform_matrix)",
		"scope": "source.vex"
	},
	"warning": {
		"body": "warning(${1:format}${2:, ...})",
		"description": "Reports a custom runtime VEX warning.",
		"prefix": "warning(format, ...)",
		"scope": "source.vex"
	},
	"wireblinn": {
		"body": "wireblinn(${1:tangent}, ${2:exponent}${3:, ...})",
		"description": "",
		"prefix": "wireblinn(tangent, exponent, ...)",
		"scope": "source.vex"
	},
	"wirediffuse": {
		"body": "wirediffuse(${1:tangent}${2:, ...})",
		"description": "",
		"prefix": "wirediffuse(tangent, ...)",
		"scope": "source.vex"
	},
	"wnoise": {
		"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:period_x}, ${6:period_y}, ${7:period_z})",
		"description": "Worley noise scatters points randomly through space (according to a\nnice Poisson distribution).",
		"prefix": "wnoise(position, seed, f1, f2, period_x, period_y, period_z)",
		"scope": "source.vex"
	},
	"wo_nspace": {
		"body": "wo_nspace(${1:n})",
		"description": "Transforms a normal vector from World to Object space.",
		"prefix": "wo_nspace(n)",
		"scope": "source.vex"
	},
	"wo_space": {
		"body": "wo_space(${1:v})",
		"description": "Transforms a position value from World to Object space.",
		"prefix": "wo_space(v)",
		"scope": "source.vex"
	},
	"wo_vspace": {
		"body": "wo_vspace(${1:v})",
		"description": "Transforms a direction vector from World to Object space.",
		"prefix": "wo_vspace(v)",
		"scope": "source.vex"
	},
	"writepixel": {
		"body": "writepixel(${1:channel}, ${2:ndc_x}, ${3:ndc_y}, ${4:clr})",
		"description": "Writes color information to a pixel in the output image ",
		"prefix": "writepixel(channel, ndc_x, ndc_y, clr)",
		"scope": "source.vex"
	},
	"wt_nspace": {
		"body": "wt_nspace(${1:n})",
		"description": "Transforms a normal vector from World to Texture space.",
		"prefix": "wt_nspace(n)",
		"scope": "source.vex"
	},
	"wt_space": {
		"body": "wt_space(${1:v})",
		"description": "Transforms a position value from World to Texture space.",
		"prefix": "wt_space(v)",
		"scope": "source.vex"
	},
	"wt_vspace": {
		"body": "wt_vspace(${1:v})",
		"description": "Transforms a direction vector from World to Texture space.",
		"prefix": "wt_vspace(v)",
		"scope": "source.vex"
	},
	"xnoise": {
		"body": "xnoise(${1:xyz})",
		"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives.",
		"prefix": "xnoise(xyz)",
		"scope": "source.vex"
	},
	"xnoised": {
		"body": "xnoised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
		"description": "Derivatives of Simplex Noise.",
		"prefix": "xnoised(xyz, v, dvdx, dvdy, dvdz)",
		"scope": "source.vex"
	},
	"xyzdist": {
		"body": "xyzdist(${1:geometry}, ${2:pt}, ${3:prim}, ${4:uv}, ${5:maxdist})",
		"description": "Finds the distance of a point to a geometry.",
		"prefix": "xyzdist(geometry, pt, prim, uv, maxdist)",
		"scope": "source.vex"
	},
	"xyztorgb": {
		"body": "xyztorgb(${1:xyz})",
		"description": "Convert CIE XYZ tristimulus values to a linear sRGB triplet.",
		"prefix": "xyztorgb(xyz)",
		"scope": "source.vex"
	}
}
